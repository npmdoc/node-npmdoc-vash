<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/kirbysayshi/vash"

    >vash (v0.12.2)</a>
</h1>
<h4>Razor syntax for JS templating</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash">module vash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.Mark">
            function <span class="apidocSignatureSpan">vash.</span>Mark
            <span class="apidocSignatureSpan">( buffer, debugName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.__express">
            function <span class="apidocSignatureSpan">vash.</span>__express
            <span class="apidocSignatureSpan">(filepath, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.batch">
            function <span class="apidocSignatureSpan">vash.</span>batch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.compile">
            function <span class="apidocSignatureSpan">vash.</span>compile
            <span class="apidocSignatureSpan">(markup, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.compileBatch">
            function <span class="apidocSignatureSpan">vash.</span>compileBatch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.compileHelper">
            function <span class="apidocSignatureSpan">vash.</span>compileHelper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.compileStream">
            function <span class="apidocSignatureSpan">vash.</span>compileStream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.constructor">
            function <span class="apidocSignatureSpan">vash.</span>helpers.constructor
            <span class="apidocSignatureSpan">( model )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.install">
            function <span class="apidocSignatureSpan">vash.</span>install
            <span class="apidocSignatureSpan">( path, tpl )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer">
            function <span class="apidocSignatureSpan">vash.</span>lexer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.link">
            function <span class="apidocSignatureSpan">vash.</span>link
            <span class="apidocSignatureSpan">( cmpFunc, options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.loadFile">
            function <span class="apidocSignatureSpan">vash.</span>loadFile
            <span class="apidocSignatureSpan">(filepath, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lookup">
            function <span class="apidocSignatureSpan">vash.</span>lookup
            <span class="apidocSignatureSpan">( path, model )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser">
            function <span class="apidocSignatureSpan">vash.</span>parser
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.renderFile">
            function <span class="apidocSignatureSpan">vash.</span>renderFile
            <span class="apidocSignatureSpan">(filepath, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.uninstall">
            function <span class="apidocSignatureSpan">vash.</span>uninstall
            <span class="apidocSignatureSpan">( path )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>Mark.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>error</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>lexer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>nodestuff</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>runtime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">vash.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.Mark">module vash.Mark</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.Mark.Mark">
            function <span class="apidocSignatureSpan">vash.</span>Mark
            <span class="apidocSignatureSpan">( buffer, debugName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.Mark.uidLike">
            function <span class="apidocSignatureSpan">vash.Mark.</span>uidLike
            <span class="apidocSignatureSpan">( str )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.Mark.</span>re</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.Mark.prototype">module vash.Mark.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.Mark.prototype.destroy">
            function <span class="apidocSignatureSpan">vash.Mark.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.Mark.prototype.findInBuffer">
            function <span class="apidocSignatureSpan">vash.Mark.prototype.</span>findInBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.error">module vash.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.error.context">
            function <span class="apidocSignatureSpan">vash.error.</span>context
            <span class="apidocSignatureSpan">(input, lineno, columnno, linebreak)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.helpers">module vash.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers._ensureLayoutProps">
            function <span class="apidocSignatureSpan">vash.helpers.</span>_ensureLayoutProps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers._handlePrependAppend">
            function <span class="apidocSignatureSpan">vash.helpers.</span>_handlePrependAppend
            <span class="apidocSignatureSpan">( type, name, ctn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.append">
            function <span class="apidocSignatureSpan">vash.helpers.</span>append
            <span class="apidocSignatureSpan">(name, ctn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.block">
            function <span class="apidocSignatureSpan">vash.helpers.</span>block
            <span class="apidocSignatureSpan">(name, ctn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.constructor">
            function <span class="apidocSignatureSpan">vash.helpers.</span>constructor
            <span class="apidocSignatureSpan">( model )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.escape">
            function <span class="apidocSignatureSpan">vash.helpers.</span>escape
            <span class="apidocSignatureSpan">( val )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.extend">
            function <span class="apidocSignatureSpan">vash.helpers.</span>extend
            <span class="apidocSignatureSpan">(path, ctn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.finishLayout">
            function <span class="apidocSignatureSpan">vash.helpers.</span>finishLayout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.highlight">
            function <span class="apidocSignatureSpan">vash.helpers.</span>highlight
            <span class="apidocSignatureSpan">(lang, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.include">
            function <span class="apidocSignatureSpan">vash.helpers.</span>include
            <span class="apidocSignatureSpan">(name, model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.prepend">
            function <span class="apidocSignatureSpan">vash.helpers.</span>prepend
            <span class="apidocSignatureSpan">(name, ctn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.raw">
            function <span class="apidocSignatureSpan">vash.helpers.</span>raw
            <span class="apidocSignatureSpan">( val )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.reportError">
            function <span class="apidocSignatureSpan">vash.helpers.</span>reportError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.toHtmlString">
            function <span class="apidocSignatureSpan">vash.helpers.</span>toHtmlString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.toString">
            function <span class="apidocSignatureSpan">vash.helpers.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.trim">
            function <span class="apidocSignatureSpan">vash.helpers.</span>trim
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.helpers.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.helpers.</span>tplcache</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.helpers.constructor">module vash.helpers.constructor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.constructor.constructor">
            function <span class="apidocSignatureSpan">vash.helpers.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.constructor.reportError">
            function <span class="apidocSignatureSpan">vash.helpers.constructor.</span>reportError
            <span class="apidocSignatureSpan">(e, lineno, chr, orig, lb, atRenderTime)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.lexer">module vash.lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer.lexer">
            function <span class="apidocSignatureSpan">vash.</span>lexer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.lexer.prototype">module vash.lexer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer.prototype.advance">
            function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>advance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer.prototype.read">
            function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer.prototype.scan">
            function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>scan
            <span class="apidocSignatureSpan">(regexp, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer.prototype.write">
            function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>write
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.nodestuff">module vash.nodestuff</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.nodestuff.clean">
            function <span class="apidocSignatureSpan">vash.nodestuff.</span>clean
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.parser">module vash.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.parser">
            function <span class="apidocSignatureSpan">vash.</span>parser
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.parser.prototype">module vash.parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.checkStack">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>checkStack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.closeNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>closeNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueBlockNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueBlockNode
            <span class="apidocSignatureSpan">(node, curr, next, ahead, nnwon)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueCommentNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueCommentNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueExplicitExpressionNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueExplicitExpressionNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueExpressionNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueExpressionNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueIndexExpressionNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueIndexExpressionNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueMarkupAttributeNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupAttributeNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueMarkupCommentNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupCommentNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueMarkupContentNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupContentNode
            <span class="apidocSignatureSpan">(node, curr, next, ahead)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueMarkupNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueRegexNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueRegexNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.decorateError">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>decorateError
            <span class="apidocSignatureSpan">(err, line, column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.dumpAST">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>dumpAST
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.flag">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>flag
            <span class="apidocSignatureSpan">(node, name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.openNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>openNode
            <span class="apidocSignatureSpan">(node, opt_insertArr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.read">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.write">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>write
            <span class="apidocSignatureSpan">(tokens)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.runtime">module vash.runtime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.runtime.Mark">
            function <span class="apidocSignatureSpan">vash.runtime.</span>Mark
            <span class="apidocSignatureSpan">( buffer, debugName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.runtime.install">
            function <span class="apidocSignatureSpan">vash.runtime.</span>install
            <span class="apidocSignatureSpan">( path, tpl )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.runtime.link">
            function <span class="apidocSignatureSpan">vash.runtime.</span>link
            <span class="apidocSignatureSpan">( cmpFunc, options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.runtime.lookup">
            function <span class="apidocSignatureSpan">vash.runtime.</span>lookup
            <span class="apidocSignatureSpan">( path, model )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.runtime.uninstall">
            function <span class="apidocSignatureSpan">vash.runtime.</span>uninstall
            <span class="apidocSignatureSpan">( path )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.runtime.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">vash.runtime.</span>version</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash" id="apidoc.module.vash">module vash</a></h1>


    <h2>
        <a href="#apidoc.element.vash.Mark" id="apidoc.element.vash.Mark">
        function <span class="apidocSignatureSpan">vash.</span>Mark
        <span class="apidocSignatureSpan">( buffer, debugName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Mark = function ( buffer, debugName ){
  this.uid = &#x27;[VASHMARK-&#x27;
    + ~~( Math.random() * 10000000 )
    + (debugName ? &#x27;:&#x27; + debugName : &#x27;&#x27;)
    + &#x27;]&#x27;;
  this.markedIndex = 0;
  this.buffer = buffer;
  this.destroyed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.__express" id="apidoc.element.vash.__express">
        function <span class="apidocSignatureSpan">vash.</span>__express
        <span class="apidocSignatureSpan">(filepath, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__express = function (filepath, options, cb){

  vash.loadFile(filepath, options, function(err, tpl){
    // auto setup an `onRenderEnd` callback to seal the layout
    var prevORE = options.onRenderEnd;

    cb( err, !err &#x26;&#x26; tpl(options, function(err, ctx){
      ctx.finishLayout()
      if( prevORE ) prevORE(err, ctx);
    }) );
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.batch" id="apidoc.element.vash.batch">
        function <span class="apidocSignatureSpan">vash.</span>batch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">batch = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.compile" id="apidoc.element.vash.compile">
        function <span class="apidocSignatureSpan">vash.</span>compile
        <span class="apidocSignatureSpan">(markup, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (markup, options) {

  if(markup === &#x27;&#x27; || typeof markup !== &#x27;string&#x27;) {
    throw new Error(&#x27;Empty or non-string cannot be compiled&#x27;);
  }

  var opts = copyrtl({}, exports.config, options || {});

  var l = new Lexer();

  l.write(markup);
  var tokens = l.read();

  var p = new Parser(opts);
  p.write(tokens);
  var more = true;
  while(more !== null) more = p.read();

  p.checkStack();

  // Stash the original input (new lines normalized by the lexer).
  opts.source = l.originalInput;

  p.lg(p.dumpAST());

  var compiled = codegen(p.stack[0], opts);
  lg(compiled);
  var tpl = runtime.link(compiled, opts);

  return tpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3c;a name=&#x22;quick-start&#x22;&#x3e;&#x3c;/a&#x3e;Quick Start
===================

&#x3c;a name=&#x22;nodejs&#x22;&#x3e;&#x3c;/a&#x3e;nodejs
--------------

	var vash = require(&#x27;vash&#x27;);
	var tpl = vash.<span class="apidocCodeKeywordSpan">compile</span>(&#x27;&#x3c;p&#x3e;I am a @model.t!&#x3c;/p&#x3e;&#x27;);

	var out = tpl({ t: &#x27;template&#x27; });
	// &#x3c;p&#x3e;I am a template!&#x3c;/p&#x3e;

&#x3c;a name=&#x22;express&#x22;&#x3e;&#x3c;/a&#x3e;express
--------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.compileBatch" id="apidoc.element.vash.compileBatch">
        function <span class="apidocSignatureSpan">vash.</span>compileBatch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileBatch = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	vash.compileHelper(str_template, opt_options) -&#x3e; Object

See [Compiled Helpers][] for more detail.

&#x3c;a name=&#x22;vash-compilebatch&#x22;&#x3e;&#x3c;/a&#x3e;vash.compileBatch
----------------------------------------------------

	vash.<span class="apidocCodeKeywordSpan">compileBatch</span>(str_template, opt_options) -&#x3e; Object

This function can take a single string containing many named templates, and output an object containing the compiled versions of
 those templates. A &#x22;named template&#x22; is of the form (similar to a `sourceURL`):

	//@batch = div
	&#x3c;div&#x3e;@model&#x3c;/div&#x3e;\n&#x27;

	//@batch = a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.compileHelper" id="apidoc.element.vash.compileHelper">
        function <span class="apidocSignatureSpan">vash.</span>compileHelper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileHelper = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	vash.compile(str_template, opt_options) -&#x3e; Function

At its core, Vash has a `compile` function that accepts a string and options, and returns a function, otherwise known as a compiled
 template. That function, when called with a parameter (otherwise known as a _model_), will use that parameter to fill in the template
. A model can be any value, including `undefined`, objects, arrays, strings, and booleans.

&#x3c;a name=&#x22;vash-compilehelper&#x22;&#x3e;&#x3c;/a&#x3e;vash.compileHelper
-----------------------------------------------------

	vash.<span class="apidocCodeKeywordSpan">compileHelper</span>(str_template, opt_options) -&#x3e; Object

See [Compiled Helpers][] for more detail.

&#x3c;a name=&#x22;vash-compilebatch&#x22;&#x3e;&#x3c;/a&#x3e;vash.compileBatch
----------------------------------------------------

	vash.compileBatch(str_template, opt_options) -&#x3e; Object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.compileStream" id="apidoc.element.vash.compileStream">
        function <span class="apidocSignatureSpan">vash.</span>compileStream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileStream = function () {
  // This could eventually handle waiting until a `null`
  // is pushed into the lexer, etc.
  throw new Error(&#x27;NotImplemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.constructor" id="apidoc.element.vash.helpers.constructor">
        function <span class="apidocSignatureSpan">vash.</span>helpers.constructor
        <span class="apidocSignatureSpan">( model )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Helpers( model ) {
  this.buffer = new Buffer();
  this.model  = model;
  this.options = null; // added at render time

  this.vl = 0;
  this.vc = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.install" id="apidoc.element.vash.install">
        function <span class="apidocSignatureSpan">vash.</span>install
        <span class="apidocSignatureSpan">( path, tpl )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function ( path, tpl ){
  var cache = runtime.helpers.tplcache;
  if( typeof tpl === &#x27;string&#x27; ){
    // Super hacky: if the calling context has a `compile` function,
    // then `this` is likely full vash. This is simply for backwards
    // compatibility.
    // TODO: @deprecate
    if ( typeof this.compile === &#x27;function&#x27;) {
      tpl = this.compile(tpl);
    } else {
      throw new Error(&#x27;.install(path, [string]) is not available in the standalone runtime.&#x27;);
    }
  } else if( typeof path === &#x27;object&#x27; ){
    tpl = path;
    Object.keys(tpl).forEach(function(path){
      cache[path] = tpl[path];
    });
    return cache;
  }
  return cache[path] = tpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If `model` is passed and the template is found, the template is automatically executed and returned using `model` as the model.

&#x3c;a name=&#x22;vash-install&#x22;&#x3e;&#x3c;/a&#x3e;vash.install
--------------------

`vash.install` accepts a few signatures:

	vash.<span class="apidocCodeKeywordSpan">install</span>(str_path, func_tpl) -&#x3e; func_tpl

&#x22;Saves&#x22; the template at `vash.helpers.tplcache[str_path]`.

	vash.install(str_path, str_tpl) -&#x3e; func_tpl

If `vash.compile` is available (meaning the entire compiler is available, not just the runtime), then the string is automatically
 compiled. and saved at `vash.helpers.tplcache[str_path]`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.lexer" id="apidoc.element.vash.lexer">
        function <span class="apidocSignatureSpan">vash.</span>lexer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VLexer(){
  this.lg = debug(&#x27;vash:lexer&#x27;);
  this.input = &#x27;&#x27;;
  this.originalInput = &#x27;&#x27;;
  this.lineno = 1;
  this.charno = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.link" id="apidoc.element.vash.link">
        function <span class="apidocSignatureSpan">vash.</span>link
        <span class="apidocSignatureSpan">( cmpFunc, options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function ( cmpFunc, options ){

  // TODO: allow options.filename to be used as sourceUrl?

  var  originalFunc
    ,cmpOpts;

  if( !options.args ){
    // every template has these arguments
    options.args = [options.modelName, options.helpersName, &#x27;__vopts&#x27;, &#x27;runtime&#x27;];
  }

  if( typeof cmpFunc === &#x27;string&#x27; ){
    originalFunc = cmpFunc;

    try {
      // do not pollute the args array for later attachment to the compiled
      // function for later decompilation/linking
      cmpOpts = options.args.slice();
      cmpOpts.push(cmpFunc);
      cmpFunc = Function.apply(null, cmpOpts);
    } catch(e) {
      // TODO: add flag to reportError to know if it&#x27;s at compile time or runtime
      helpers.reportError(e, 0, 0, originalFunc, /\n/, false);
    }
  }

  // need this to enable decompilation / relinking
  cmpFunc.options = {
     simple: options.simple
    ,modelName: options.modelName
    ,helpersName: options.helpersName
  }

  var linked;

  if( options.asHelper ){

    cmpFunc.options.args = options.args;
    cmpFunc.options.asHelper = options.asHelper;

    linked = function(){
      return cmpFunc.apply(this, slice.call(arguments));
    }

    helpers[options.asHelper] = linked;

  } else {

    linked = function( model, opts ){
      if( options.simple ){
        var ctx = {
           buffer: []
          ,escape: Helpers.prototype.escape
          ,raw: Helpers.prototype.raw
        }
        return cmpFunc( model, ctx, opts, runtime );
      }

      opts = divineRuntimeTplOptions( model, opts );
      return cmpFunc( model, (opts &#x26;&#x26; opts.context) || new Helpers( model ), opts, runtime );
    }
  }

  // show the template-specific code, instead of the generic linked function
  linked[&#x27;toString&#x27;] = function(){ return cmpFunc.toString(); }

  // shortcut to show the actual linked function
  linked[&#x27;_toString&#x27;] = function(){ return Function.prototype.toString.call(linked) }

  // This assumes a vash global, and should be deprecated.
  // TODO: @deprecate
  linked[&#x27;toClientString&#x27;] = function(){
    return &#x27;vash.link( &#x27;
      + cmpFunc.toString() + &#x27;, &#x27;
      + JSON.stringify( cmpFunc.options ) + &#x27; )&#x27;;
  }

  return linked;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		return (__vopts &#x26;&#x26; __vopts.asContext)
			? html
			: html.toString();
	}

If `toClientString` is called on that function, the following is returned:

	vash.<span class="apidocCodeKeywordSpan">link</span>( function anonymous(model,html,__vopts,vash) {
		var __vbuffer = html.buffer;
		html.options = __vopts;
		model = model || {};
		__vbuffer.push(&#x27;&#x3c;p&#x3e;&#x3c;/p&#x3e;\n&#x27;);
		(__vopts &#x26;&#x26; __vopts.onRenderEnd &#x26;&#x26; __vopts.onRenderEnd(null, html));
		return (__vopts &#x26;&#x26; __vopts.asContext)
			? html
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.loadFile" id="apidoc.element.vash.loadFile">
        function <span class="apidocSignatureSpan">vash.</span>loadFile
        <span class="apidocSignatureSpan">(filepath, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadFile = function (filepath, options, cb){

  // options are passed in via Express
  // {
  //   settings:
  //   {
  //      env: &#x27;development&#x27;,
  //    &#x27;jsonp callback name&#x27;: &#x27;callback&#x27;,
  //    &#x27;json spaces&#x27;: 2,
  //    views: &#x27;/Users/drew/Dropbox/js/vash/test/fixtures/views&#x27;,
  //    &#x27;view engine&#x27;: &#x27;vash&#x27;
  //   },
  //   _locals: [Function: locals],
  //   cache: false
  // }

  // The only required options are:
  //
  // settings: {
  //     views: &#x27;&#x27;
  // }

  options = copyrtl({}, vash.config, options || {});

  var browser = helpers.config.browser
    ,tpl

  if( !browser &#x26;&#x26; options.settings &#x26;&#x26; options.settings.views ){
    // this will really only have an effect on windows
    filepath = path.normalize( filepath );

    if( filepath.indexOf( path.normalize( options.settings.views ) ) === -1 ){
      // not an absolute path
      filepath = path.join( options.settings.views, filepath );
    }

    if( !path.extname( filepath ) ){
      filepath += &#x27;.&#x27; + ( options.settings[&#x27;view engine&#x27;] || &#x27;vash&#x27; )
    }
  }

  // TODO: auto insert &#x27;model&#x27; into arguments
  try {
    // if browser, tpl must exist in tpl cache
    tpl = options.cache || browser
      ? helpers.tplcache[filepath] || ( helpers.tplcache[filepath] = vash.compile(fs.readFileSync(filepath, &#x27;utf8&#x27;)) )
      : vash.compile( fs.readFileSync(filepath, &#x27;utf8&#x27;) )

    cb &#x26;&#x26; cb(null, tpl);
  } catch(e) {
    cb &#x26;&#x26; cb(e, null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.lookup" id="apidoc.element.vash.lookup">
        function <span class="apidocSignatureSpan">vash.</span>lookup
        <span class="apidocSignatureSpan">( path, model )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function ( path, model ){
  var tpl = runtime.helpers.tplcache[path];
  if( !tpl ){ throw new Error(&#x27;Could not find template: &#x27; + path); }
  if( model ){ return tpl(model); }
  else return tpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This is primarily an internal function, and has relatively complex behavioral differences depending on what options are passed in
. It takes either a decompiled string function or function instance and &#x22;links&#x22; it by wrapping it in a closure that provides
 access to Vash&#x27;s runtime functions. It also sets up things like `toClientString` and `toString`. It makes precompiled functions
 possible. As a developer working on Vash, it&#x27;s best to take a look at the [source itself][].

[source itself]: https://github.com/kirbysayshi/vash/blob/master/src/vruntime.js

&#x3c;a name=&#x22;vash-lookup&#x22;&#x3e;&#x3c;/a&#x3e;vash.lookup
-------------------

	vash.<span class="apidocCodeKeywordSpan">lookup</span>(str_path) -&#x3e; Function

Attempts to grab a template from `vash.helpers.tplcache[str_path]`, and throws an exception if it is not found.

	vash.lookup(str_path, model) -&#x3e; Function

If `model` is passed and the template is found, the template is automatically executed and returned using `model` as the model.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser" id="apidoc.element.vash.parser">
        function <span class="apidocSignatureSpan">vash.</span>parser
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(opts) {
  this.lg = debug(&#x27;vash:parser&#x27;);
  this.tokens = [];
  this.deferredTokens = [];
  this.node = null;
  this.stack = [];
  this.inputText = &#x27;&#x27;;
  this.opts = opts || {};
  this.previousNonWhitespace = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.renderFile" id="apidoc.element.vash.renderFile">
        function <span class="apidocSignatureSpan">vash.</span>renderFile
        <span class="apidocSignatureSpan">(filepath, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderFile = function (filepath, options, cb){

  vash.loadFile(filepath, options, function(err, tpl){
    // auto setup an `onRenderEnd` callback to seal the layout
    var prevORE = options.onRenderEnd;

    cb( err, !err &#x26;&#x26; tpl(options, function(err, ctx){
      ctx.finishLayout()
      if( prevORE ) prevORE(err, ctx);
    }) );
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.uninstall" id="apidoc.element.vash.uninstall">
        function <span class="apidocSignatureSpan">vash.</span>uninstall
        <span class="apidocSignatureSpan">( path )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function ( path ){
  var  cache = runtime.helpers.tplcache
    ,deleted = false;

  if( typeof path === &#x27;string&#x27; ){
    return delete cache[path];
  } else {
    Object.keys(cache).forEach(function(key){
      if( cache[key] === path ){ deleted = delete cache[key]; }
    })
    return deleted;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	vash.install(obj) -&#x3e; obj

If an object containing string keys pointing at template functions is passed, then the object&#x27;s keys are used as the keys for
 `vash.helpers.tplcache`. This is especially useful when using [vash.compileBatch][], as the result can be directly passed.

&#x3c;a name=&#x22;vash-uninstall&#x22;&#x3e;&#x3c;/a&#x3e;vash.uninstall
----------------------

	vash.<span class="apidocCodeKeywordSpan">uninstall</span>(str_path) -&#x3e; bool

Deletes the key named `str_path` from `vash.helpers.tplcache`.

	vash.uninstall(func_tpl) -&#x3e; bool

Loops through all templates in `vash.helpers.tplcache`, and if a strict equality is successful, deletes that reference.
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.Mark" id="apidoc.module.vash.Mark">module vash.Mark</a></h1>


    <h2>
        <a href="#apidoc.element.vash.Mark.Mark" id="apidoc.element.vash.Mark.Mark">
        function <span class="apidocSignatureSpan">vash.</span>Mark
        <span class="apidocSignatureSpan">( buffer, debugName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Mark = function ( buffer, debugName ){
  this.uid = &#x27;[VASHMARK-&#x27;
    + ~~( Math.random() * 10000000 )
    + (debugName ? &#x27;:&#x27; + debugName : &#x27;&#x27;)
    + &#x27;]&#x27;;
  this.markedIndex = 0;
  this.buffer = buffer;
  this.destroyed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.Mark.uidLike" id="apidoc.element.vash.Mark.uidLike">
        function <span class="apidocSignatureSpan">vash.Mark.</span>uidLike
        <span class="apidocSignatureSpan">( str )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uidLike = function ( str ){
  return (str || &#x27;&#x27;).search( reMark ) &#x3e; -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.Mark.prototype" id="apidoc.module.vash.Mark.prototype">module vash.Mark.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.vash.Mark.prototype.destroy" id="apidoc.element.vash.Mark.prototype.destroy">
        function <span class="apidocSignatureSpan">vash.Mark.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (){

  var found = this.findInBuffer();

  if( found &#x3e; -1 ){
    this.buffer.splice( found, 1 );
    this.markedIndex = -1;
  }

  this.destroyed = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Buffer.prototype.fromMark = function( mark ) {
  var found = mark.findInBuffer();

  if( found &#x3e; -1 ){
    // automatically destroy the mark from the buffer
    mark.<span class="apidocCodeKeywordSpan">destroy</span>();
    // `found` will still be valid for a manual splice
    return this._vo.splice( found, this._vo.length );
  }

  return [];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.Mark.prototype.findInBuffer" id="apidoc.element.vash.Mark.prototype.findInBuffer">
        function <span class="apidocSignatureSpan">vash.Mark.prototype.</span>findInBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findInBuffer = function (){

  if( this.destroyed ){
    return -1;
  }

  if( this.markedIndex &#x26;&#x26; this.buffer.index( this.markedIndex ) === this.uid ){
    return this.markedIndex;
  }

  // The mark may be within a string due to block manipulation shenanigans.
  var escaped = this.uid.replace(/(\[|\])/g, &#x27;\\$1&#x27;);
  var re = new RegExp(escaped);
  return this.markedIndex = this.buffer.indexOf( re );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var mark = new Mark( this, debugName );
mark.markedIndex = this._vo.length;
this._vo.push( mark.uid );
return mark;
};

Buffer.prototype.fromMark = function( mark ) {
var found = mark.<span class="apidocCodeKeywordSpan">findInBuffer</span>();

if( found &#x3e; -1 ){
  // automatically destroy the mark from the buffer
  mark.destroy();
  // `found` will still be valid for a manual splice
  return this._vo.splice( found, this._vo.length );
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.error" id="apidoc.module.vash.error">module vash.error</a></h1>


    <h2>
        <a href="#apidoc.element.vash.error.context" id="apidoc.element.vash.error.context">
        function <span class="apidocSignatureSpan">vash.error.</span>context
        <span class="apidocSignatureSpan">(input, lineno, columnno, linebreak)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">context = function (input, lineno, columnno, linebreak) {
  linebreak = linebreak || &#x27;!LB!&#x27;;

  var lines = input.split(linebreak)
    , contextSize = lineno === 0 &#x26;&#x26; columnno === 0 ? lines.length - 1 : 3
    , start = Math.max(0, lineno - contextSize)
    , end = Math.min(lines.length, lineno + contextSize);

  return lines
    .slice(start, end)
    .map(function(line, i, all){
      var curr = i + start + 1;

      return (curr === lineno ? &#x27;  &#x3e; &#x27; : &#x27;    &#x27;)
        + (curr &#x3c; 10 ? &#x27; &#x27; : &#x27;&#x27;)
        + curr
        + &#x27; | &#x27;
        + line;
    }).join(&#x27;\n&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Parser.prototype.decorateError = function(err, line, column) {
err.message = &#x27;&#x27;
  + err.message
  + &#x27; at template line &#x27; + line
  + &#x27;, column &#x27; + column + &#x27;\n\n&#x27;
  + &#x27;Context: \n&#x27;
  + error.<span class="apidocCodeKeywordSpan">context</span>(this.inputText, line, column, &#x27;\n&#x27;)
  + &#x27;\n&#x27;;

return err;
}

Parser.prototype.write = function(tokens) {
if (!Array.isArray(tokens)) tokens = [tokens];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.helpers" id="apidoc.module.vash.helpers">module vash.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.vash.helpers._ensureLayoutProps" id="apidoc.element.vash.helpers._ensureLayoutProps">
        function <span class="apidocSignatureSpan">vash.helpers.</span>_ensureLayoutProps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_ensureLayoutProps = function (){
  this.appends = this.appends || {};
  this.prepends = this.prepends || {};
  this.blocks = this.blocks || {};

  this.blockMarks = this.blockMarks || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers._handlePrependAppend" id="apidoc.element.vash.helpers._handlePrependAppend">
        function <span class="apidocSignatureSpan">vash.helpers.</span>_handlePrependAppend
        <span class="apidocSignatureSpan">( type, name, ctn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handlePrependAppend = function ( type, name, ctn ){
  this._ensureLayoutProps();

  var start = this.buffer.mark()
    ,content
    ,stack = this[type]
    ,namedStack = stack[name] || ( stack[name] = [] )

  ctn( this.model );
  content = this.buffer.fromMark( start );

  namedStack.push( content );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.append" id="apidoc.element.vash.helpers.append">
        function <span class="apidocSignatureSpan">vash.helpers.</span>append
        <span class="apidocSignatureSpan">(name, ctn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (name, ctn){
  this._handlePrependAppend( &#x27;appends&#x27;, name, ctn );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if
it is referenced in the content. This may change in a future version of Vash._


&#x3c;a name=&#x22;vash-helpers-append&#x22;&#x3e;&#x3c;/a&#x3e;vash.helpers.append
---------------------------

	vash.helpers.<span class="apidocCodeKeywordSpan">append</span>(name, cb)

[vash.helpers.append][] is a way to control the content of a block from within an extending template. In this way, it allows templates
 to invert control over content &#x22;above&#x22; them.

An example is a navigation area. Perhaps there is a default navigation list that templates can add to:

	// layout.vash
	&#x3c;ul&#x3e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.block" id="apidoc.element.vash.helpers.block">
        function <span class="apidocSignatureSpan">vash.helpers.</span>block
        <span class="apidocSignatureSpan">(name, ctn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function (name, ctn){
  this._ensureLayoutProps();

  var  self = this
    // ensure that we have a list of marks for this name
    ,marks = this.blockMarks[name] || ( this.blockMarks[name] = [] )
    // ensure a list of blocks for this name
    ,blocks = this.blocks[name] || ( this.blocks[name] = [] )
    ,start
    ,content;

  // render out the content immediately, if defined, to attempt to grab
  // &#x22;dependencies&#x22; like other includes, blocks, etc
  if( ctn ){
    start = this.buffer.mark();
    ctn( this.model );
    content = this.buffer.fromMark( start );

    // add rendered content to named list of blocks
    if( content.length &#x26;&#x26; !this.isExtending ){
      blocks.push( content );
    }

    // if extending the rendered content must be allowed to be redefined
    if( content.length &#x26;&#x26; this.isExtending ){
      blocks.unshift( content );
    }
  }

  // mark the current location as &#x22;where this block will end up&#x22;
  marks.push( this.buffer.mark( &#x27;block-&#x27; + name ) );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This is Vash&#x27;s main form of inheritance for view templates. `parent_path` is the location or name of the template to be extended
.

A template can define various locations in itself that can be [overridden](#vash-helpers-block) or [added to](#vash-helpers-append
). In addition, a template that calls `extend` can even be extended itself!

In the following example, this template extends another named [layout.vash][]. [Layout.vash][] defines an empty [block](#vash-helpers
-block) named &#x27;content&#x27;, which is overrided in this example.

	@html.extend(&#x27;layout&#x27;, function(model){
		@html.<span class="apidocCodeKeywordSpan">block</span>(&#x27;content&#x27;, function(model){
			&#x3c;h1 class=&#x22;name&#x22;&#x3e;Welcome to &#x3c;/h1&#x3e;
		})
	})

_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if
it is referenced in the content. This may change in a future version of Vash._
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.constructor" id="apidoc.element.vash.helpers.constructor">
        function <span class="apidocSignatureSpan">vash.helpers.</span>constructor
        <span class="apidocSignatureSpan">( model )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Helpers( model ) {
  this.buffer = new Buffer();
  this.model  = model;
  this.options = null; // added at render time

  this.vl = 0;
  this.vc = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.escape" id="apidoc.element.vash.helpers.escape">
        function <span class="apidocSignatureSpan">vash.helpers.</span>escape
        <span class="apidocSignatureSpan">( val )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function ( val ) {
  var func = function() { return val; };

  val = val != null ? val : &#x22;&#x22;;

  if ( typeof val.toHtmlString !== &#x22;function&#x22; ) {

    val = val.toString().replace( HTML_REGEX, HTML_REPLACER );

    return {
       toHtmlString: func
      ,toString: func
    };
  }

  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    + opts.helpersName + &#x27;.vl = &#x27; + node.endloc.line + &#x27;, &#x27;
    + opts.helpersName + &#x27;.vc = &#x27; + node.endloc.column + &#x27;; \n&#x27;
  : &#x27;&#x27;;
}

function maybeHTMLEscape(node, opts, str) {
if (parentIsContent(node) &#x26;&#x26; opts.htmlEscape) {
  return opts.helpersName + &#x27;.<span class="apidocCodeKeywordSpan">escape</span>(&#x27; + str + &#x27;).toHtmlString()&#x27;;
} else {
  return str;
}
}

function replaceDevTokens(str, opts){
return str
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.extend" id="apidoc.element.vash.helpers.extend">
        function <span class="apidocSignatureSpan">vash.helpers.</span>extend
        <span class="apidocSignatureSpan">(path, ctn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (path, ctn){
  var  self = this
    ,buffer = this.buffer
    ,origModel = this.model
    ,layoutCtx;

  this._ensureLayoutProps();

  // this is a synchronous callback
  vash.loadFile(path, this.model, function(err, tpl){

    if (err) throw err;

    // any content that is outside of a block but within an &#x22;extend&#x22;
    // callback is completely thrown away, as the destination for such
    // content is undefined
    var start = self.buffer.mark();

    ctn(self.model);

    // ... and just throw it away
    var  content = self.buffer.fromMark( start )
      // TODO: unless it&#x27;s a mark id? Removing everything means a block
      // MUST NOT be defined in an extend callback
      //,filtered = content.filter( vash.Mark.uidLike )

    //self.buffer.push( filtered );

    // `isExtending` is necessary because named blocks in the layout
    // will be interpreted after named blocks in the content. Since
    // layout named blocks should only be used as placeholders in the
    // event that their content is redefined, `block` must know to add
    // the defined content at the head or tail or the block stack.
    self.isExtending = true;
    tpl( self.model, { context: self } );
    self.isExtending = false;
  });

  this.model = origModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[Layout.vash]: https://github.com/kirbysayshi/vash-express-example/blob/master/views/layout.vash



&#x3c;a name=&#x22;vash-helpers-extend&#x22;&#x3e;&#x3c;/a&#x3e;vash.helpers.extend
---------------------------

	vash.helpers.<span class="apidocCodeKeywordSpan">extend</span>(parent_path, cb)

This is Vash&#x27;s main form of inheritance for view templates. `parent_path` is the location or name of the template to be extended
.

A template can define various locations in itself that can be [overridden](#vash-helpers-block) or [added to](#vash-helpers-append
). In addition, a template that calls `extend` can even be extended itself!

In the following example, this template extends another named [layout.vash][]. [Layout.vash][] defines an empty [block](#vash-helpers
-block) named &#x27;content&#x27;, which is overrided in this example.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.finishLayout" id="apidoc.element.vash.helpers.finishLayout">
        function <span class="apidocSignatureSpan">vash.helpers.</span>finishLayout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishLayout = function (){
  this._ensureLayoutProps();

  var self = this, name, marks, blocks, prepends, appends, injectMark, m, content, block

  // each time `.block` is called, a mark is added to the buffer and
  // the `blockMarks` stack. Find the newest/&#x22;highest&#x22; mark on the stack
  // for each named block, and insert the rendered content (prepends, block, appends)
  // in place of that mark

  for( name in this.blockMarks ){

    marks = this.blockMarks[name];

    prepends = this.prepends[name];
    blocks = this.blocks[name];
    appends = this.appends[name];

    injectMark = marks.pop();

    // mark current point in buffer in prep to grab rendered content
    m = this.buffer.mark();

    prepends &#x26;&#x26; prepends.forEach(function(p){ self.buffer.pushConcat( p ); });

    // a block might never have a callback defined, e.g. is optional
    // with no default content
    block = blocks.pop();
    block &#x26;&#x26; this.buffer.pushConcat( block );

    appends &#x26;&#x26; appends.forEach(function(a){ self.buffer.pushConcat( a ); });

    // grab rendered content
    content = this.buffer.fromMark( m )

    // Join, but split out the VASHMARKS so further buffer operations are still
    // sane. Join is required to prevent max argument errors when large templates
    // are being used.
    content = compactContent(content);

    // Prep for apply, ensure the right location (mark) is used for injection.
    content.unshift( injectMark, 0 );
    this.buffer.spliceMark.apply( this.buffer, content );
  }

  for( name in this.blockMarks ){

    // kill all other marks registered as blocks
    this.blockMarks[name].forEach(function(m){ m.destroy(); });
  }

  // this should only be able to happen once
  delete this.blockMarks;
  delete this.prepends;
  delete this.blocks;
  delete this.appends;

  // and return the whole thing
  return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.highlight" id="apidoc.element.vash.helpers.highlight">
        function <span class="apidocSignatureSpan">vash.helpers.</span>highlight
        <span class="apidocSignatureSpan">(lang, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">highlight = function (lang, cb){

  // context (this) is and instance of Helpers, aka a rendering context

  // mark() returns an internal `Mark` object
  // Use it to easily capture output...
  var startMark = this.buffer.mark();

  // cb() is simply a user-defined function. It could (and should) contain
  // buffer additions, so we call it...
  cb( this.model );

  // ... and then use fromMark() to grab the output added by cb().
  var cbOutLines = this.buffer.fromMark(startMark);

  // The internal buffer should now be back to where it was before this
  // helper started, and the output is completely contained within cbOutLines.

  this.buffer.push( &#x27;&#x3c;pre&#x3e;&#x3c;code&#x3e;&#x27; );

  if( helpers.config.highlighter ){
    this.buffer.push( helpers.config.highlighter(lang, cbOutLines.join(&#x27;&#x27;)).value );
  } else {
    this.buffer.push( cbOutLines );
  }

  this.buffer.push( &#x27;&#x3c;/code&#x3e;&#x3c;/pre&#x3e;&#x27; );

  // returning is allowed, but could cause surprising effects. A return
  // value will be directly added to the output directly following the above.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.include" id="apidoc.element.vash.helpers.include">
        function <span class="apidocSignatureSpan">vash.helpers.</span>include
        <span class="apidocSignatureSpan">(name, model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">include = function (name, model){

  var  self = this
    ,buffer = this.buffer
    ,origModel = this.model;

  // TODO: should this be in a new context? Jade looks like an include
  // is not shared with parent context

  // this is a synchronous callback
  vash.loadFile(name, this.model, function(err, tpl){
    if (err) throw err;
    tpl( model || self.model, { context: self } );
  });

  this.model = origModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if
it is referenced in the content. This may change in a future version of Vash._


&#x3c;a name=&#x22;vash-helpers-include&#x22;&#x3e;&#x3c;/a&#x3e;vash.helpers.include
----------------------------

	vash.helpers.<span class="apidocCodeKeywordSpan">include</span>(name, model)

This grabs the template `name` and executes it using `model` as the... model. [vash.helpers.include][] is used to literally include
 the contents of another template. It is analogous to a &#x22;partial&#x22; in other view engines. Except that there is a hidden
 power here... as included templates share the same &#x22;view engine scope&#x22; as other templates, and can thus call all of the
 layout helper functions, and it will _just work_. Thus, a block within an included template can append to a block defined in a
parent. It can even use [vash.helpers.extend][]!

&#x3c;a name=&#x22;compiled-helpers&#x22;&#x3e;&#x3c;/a&#x3e;Compiled Helpers
========================

A relatively new feature in Vash (added in 0.6), compiled helpers are a bit meta. They allow a developer to write a helper using
 Vash syntax instead of the manual buffer API. The below buffer API example `imgfigure` could be rewritten:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.prepend" id="apidoc.element.vash.helpers.prepend">
        function <span class="apidocSignatureSpan">vash.helpers.</span>prepend
        <span class="apidocSignatureSpan">(name, ctn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (name, ctn){
  this._handlePrependAppend( &#x27;prepends&#x27;, name, ctn );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if
it is referenced in the content. This may change in a future version of Vash._


&#x3c;a name=&#x22;vash-helpers-prepend&#x22;&#x3e;&#x3c;/a&#x3e;vash.helpers.prepend
----------------------------

	vash.helpers.<span class="apidocCodeKeywordSpan">prepend</span>(name, cb)

[vash.helpers.prepend][] behaves nearly the same as [vash.helpers.append][] except that it places content at the beginning of a
block instead of at the end. The previous example, if `prepend` were substituted for `append`, would render as:

	&#x3c;li&#x3e;&#x3c;a href=&#x22;/another&#x22;&#x3e;Another Link&#x3c;/a&#x3e;&#x3c;/li&#x3e;
	&#x3c;li&#x3e;&#x3c;a href=&#x22;/&#x22;&#x3e;Home&#x3c;/a&#x3e;&#x3c;/li&#x3e;

_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if
it is referenced in the content. This may change in a future version of Vash._
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.raw" id="apidoc.element.vash.helpers.raw">
        function <span class="apidocSignatureSpan">vash.helpers.</span>raw
        <span class="apidocSignatureSpan">( val )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">raw = function ( val ) {
  var func = function() { return val; };

  val = val != null ? val : &#x22;&#x22;;

  return {
     toHtmlString: func
    ,toString: func
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	&#x3c;p&#x3e;&#x26;lt;img /&#x26;gt;&#x3c;/p&#x3e;

If you are sure that you trust the content and/or need to display HTML-like values, you can escape the HTML escaping via a call
to Vash&#x27;s [helper system][]: `html.raw`.

input:

	// model = { what: &#x27;&#x3c;img /&#x3e;&#x27; }
	&#x3c;p&#x3e;@html.<span class="apidocCodeKeywordSpan">raw</span>(model.what)&#x3c;/p&#x3e;

output:

	&#x3c;p&#x3e;&#x3c;img /&#x3e;&#x3c;/p&#x3e;

This behavior can be disabled using [vash.config.htmlEscape][].
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.reportError" id="apidoc.element.vash.helpers.reportError">
        function <span class="apidocSignatureSpan">vash.helpers.</span>reportError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportError = function () {
  this.constructor.reportError.apply( this, arguments );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			html.vl = 1, html.vc = 7;
			__vbuffer.push(&#x27;\n&#x27;);
			(__vopts &#x26;&#x26; __vopts.onRenderEnd &#x26;&#x26; __vopts.onRenderEnd(null, html));
			return (__vopts &#x26;&#x26; __vopts.asContext)
				? html
				: html.toString();
		} catch( e ){
			html.<span class="apidocCodeKeywordSpan">reportError</span>( e, html.vl, html.vc, &#x22;&#x3c;p&#x3e;&#x3c;/p&#x3e;!LB!&#x22; );
		}
	}

And that same template with `debug` set to `false`:

	function anonymous(model,html,__vopts,vash) {
		var __vbuffer = html.buffer;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.toHtmlString" id="apidoc.element.vash.helpers.toHtmlString">
        function <span class="apidocSignatureSpan">vash.helpers.</span>toHtmlString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHtmlString = function (){
  // not calling buffer.toString() results in 2x speedup
  return this.buffer._vo.join(&#x27;&#x27;);//.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    + opts.helpersName + &#x27;.vl = &#x27; + node.endloc.line + &#x27;, &#x27;
    + opts.helpersName + &#x27;.vc = &#x27; + node.endloc.column + &#x27;; \n&#x27;
  : &#x27;&#x27;;
}

function maybeHTMLEscape(node, opts, str) {
if (parentIsContent(node) &#x26;&#x26; opts.htmlEscape) {
  return opts.helpersName + &#x27;.escape(&#x27; + str + &#x27;).<span class="apidocCodeKeywordSpan">toHtmlString</span>()&#x27;;
} else {
  return str;
}
}

function replaceDevTokens(str, opts){
return str
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.toString" id="apidoc.element.vash.helpers.toString">
        function <span class="apidocSignatureSpan">vash.helpers.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (){
  // not calling buffer.toString() results in 2x speedup
  return this.buffer._vo.join(&#x27;&#x27;);//.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			html.vl = 1, html.vc = 3;
			__vbuffer.push(&#x27;&#x3c;/p&#x3e;&#x27;);
			html.vl = 1, html.vc = 7;
			__vbuffer.push(&#x27;\n&#x27;);
			(__vopts &#x26;&#x26; __vopts.onRenderEnd &#x26;&#x26; __vopts.onRenderEnd(null, html));
			return (__vopts &#x26;&#x26; __vopts.asContext)
				? html
				: html.<span class="apidocCodeKeywordSpan">toString</span>();
		} catch( e ){
			html.reportError( e, html.vl, html.vc, &#x22;&#x3c;p&#x3e;&#x3c;/p&#x3e;!LB!&#x22; );
		}
	}

And that same template with `debug` set to `false`:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.trim" id="apidoc.element.vash.helpers.trim">
        function <span class="apidocSignatureSpan">vash.helpers.</span>trim
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trim = function (val){
  return val.replace(/^\s*|\s*$/g, &#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.helpers.constructor" id="apidoc.module.vash.helpers.constructor">module vash.helpers.constructor</a></h1>


    <h2>
        <a href="#apidoc.element.vash.helpers.constructor.constructor" id="apidoc.element.vash.helpers.constructor.constructor">
        function <span class="apidocSignatureSpan">vash.helpers.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Function() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.constructor.reportError" id="apidoc.element.vash.helpers.constructor.reportError">
        function <span class="apidocSignatureSpan">vash.helpers.constructor.</span>reportError
        <span class="apidocSignatureSpan">(e, lineno, chr, orig, lb, atRenderTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportError = function (e, lineno, chr, orig, lb, atRenderTime){

  lb = lb || &#x27;!LB!&#x27;;

  var contextStr = error.context(orig, lineno, chr, lb);

  e.vashlineno = lineno;
  e.vashcharno = chr;
  e.message = &#x27;Problem while &#x27;
    + (atRenderTime ? &#x27;rendering&#x27; : &#x27;compiling&#x27;)
    + &#x27; template at line &#x27;
    + lineno + &#x27;, character &#x27; + chr
    + &#x27;.\nOriginal message: &#x27; + e.message + &#x27;.&#x27;
    + &#x27;\nContext: \n\n&#x27; + contextStr + &#x27;\n\n&#x27;;

  throw e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			html.vl = 1, html.vc = 7;
			__vbuffer.push(&#x27;\n&#x27;);
			(__vopts &#x26;&#x26; __vopts.onRenderEnd &#x26;&#x26; __vopts.onRenderEnd(null, html));
			return (__vopts &#x26;&#x26; __vopts.asContext)
				? html
				: html.toString();
		} catch( e ){
			html.<span class="apidocCodeKeywordSpan">reportError</span>( e, html.vl, html.vc, &#x22;&#x3c;p&#x3e;&#x3c;/p&#x3e;!LB!&#x22; );
		}
	}

And that same template with `debug` set to `false`:

	function anonymous(model,html,__vopts,vash) {
		var __vbuffer = html.buffer;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.lexer" id="apidoc.module.vash.lexer">module vash.lexer</a></h1>


    <h2>
        <a href="#apidoc.element.vash.lexer.lexer" id="apidoc.element.vash.lexer.lexer">
        function <span class="apidocSignatureSpan">vash.</span>lexer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VLexer(){
  this.lg = debug(&#x27;vash:lexer&#x27;);
  this.input = &#x27;&#x27;;
  this.originalInput = &#x27;&#x27;;
  this.lineno = 1;
  this.charno = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.lexer.prototype" id="apidoc.module.vash.lexer.prototype">module vash.lexer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.vash.lexer.prototype.advance" id="apidoc.element.vash.lexer.prototype.advance">
        function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>advance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">advance = function () {

  var i, name, test, result;

  for(i = 0; i &#x3c; tokens.tests.length; i += 2){
    test = tokens.tests[i+1];
    test.displayName = tokens.tests[i];

    if(typeof test === &#x27;function&#x27;){
      // assume complex callback
      result = test.call(this);
    }

    if(typeof test.exec === &#x27;function&#x27;){
      // assume regex
      result = this.scan(test, tokens.tests[i]);
    }

    if( result ){
      return result;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return true;
},

read: function() {
  var out = []
    , result;
  while(this.input.length) {
    result = this.<span class="apidocCodeKeywordSpan">advance</span>();
    if (result) {
      out.push(result);
      this.lg(&#x27;Read %s at line %d, column %d with content %s&#x27;,
        result.type, result.line, result.chr, result.val.replace(/(\n)/, &#x27;\\n&#x27;));
    }
  }
  return out;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.lexer.prototype.read" id="apidoc.element.vash.lexer.prototype.read">
        function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {
  var out = []
    , result;
  while(this.input.length) {
    result = this.advance();
    if (result) {
      out.push(result);
      this.lg(&#x27;Read %s at line %d, column %d with content %s&#x27;,
        result.type, result.line, result.chr, result.val.replace(/(\n)/, &#x27;\\n&#x27;));
    }
  }
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var opts = copyrtl({}, exports.config, options || {});

var l = new Lexer();

l.write(markup);
var tokens = l.<span class="apidocCodeKeywordSpan">read</span>();

var p = new Parser(opts);
p.write(tokens);
var more = true;
while(more !== null) more = p.read();

p.checkStack();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.lexer.prototype.scan" id="apidoc.element.vash.lexer.prototype.scan">
        function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>scan
        <span class="apidocSignatureSpan">(regexp, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scan = function (regexp, type){
  var captures, token;
  if (captures = regexp.exec(this.input)) {
    this.input = this.input.substr((captures[1].length));

    token = {
      type: type
      ,line: this.lineno
      ,chr: this.charno
      ,val: captures[1] || &#x27;&#x27;
      ,toString: function(){
        return &#x27;[&#x27; + this.type
          + &#x27; (&#x27; + this.line + &#x27;,&#x27; + this.chr + &#x27;): &#x27;
          + this.val.replace(/(\n)/, &#x27;\\n&#x27;) + &#x27;]&#x27;;
      }
    };

    this.charno += captures[0].length;
    return token;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(typeof test === &#x27;function&#x27;){
      // assume complex callback
      result = test.call(this);
    }

    if(typeof test.exec === &#x27;function&#x27;){
      // assume regex
      result = this.<span class="apidocCodeKeywordSpan">scan</span>(test, tokens.tests[i]);
    }

    if( result ){
      return result;
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.lexer.prototype.write" id="apidoc.element.vash.lexer.prototype.write">
        function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>write
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (input) {
  var normalized = input.replace(/\r\n|\r/g, &#x27;\n&#x27;);

  // Kill BOM if this is the first chunk.
  if (this.originalInput.length == 0) {
    normalized = normalized.replace(/^\uFEFF/, &#x27;&#x27;);
  }

  this.input += normalized;
  this.originalInput += normalized;
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error(&#x27;Empty or non-string cannot be compiled&#x27;);
}

var opts = copyrtl({}, exports.config, options || {});

var l = new Lexer();

l.<span class="apidocCodeKeywordSpan">write</span>(markup);
var tokens = l.read();

var p = new Parser(opts);
p.write(tokens);
var more = true;
while(more !== null) more = p.read();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.nodestuff" id="apidoc.module.vash.nodestuff">module vash.nodestuff</a></h1>


    <h2>
        <a href="#apidoc.element.vash.nodestuff.clean" id="apidoc.element.vash.nodestuff.clean">
        function <span class="apidocSignatureSpan">vash.nodestuff.</span>clean
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clean(node) {
  return Object.keys(node).reduce(function(out, key) {
    var value = node[key];
    if (key[0] !== &#x27;_&#x27; &#x26;&#x26; typeof value !== &#x27;function&#x27;) {
      if (Array.isArray(value)) {
        out[key] = value.map(clean);
      } else {
        out[key] = value;
      }
    }
    return out;
  }, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.parser" id="apidoc.module.vash.parser">module vash.parser</a></h1>


    <h2>
        <a href="#apidoc.element.vash.parser.parser" id="apidoc.element.vash.parser.parser">
        function <span class="apidocSignatureSpan">vash.</span>parser
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(opts) {
  this.lg = debug(&#x27;vash:parser&#x27;);
  this.tokens = [];
  this.deferredTokens = [];
  this.node = null;
  this.stack = [];
  this.inputText = &#x27;&#x27;;
  this.opts = opts || {};
  this.previousNonWhitespace = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.parser.prototype" id="apidoc.module.vash.parser.prototype">module vash.parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.vash.parser.prototype.checkStack" id="apidoc.element.vash.parser.prototype.checkStack">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>checkStack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkStack = function () {
  // Throw if something is unclosed that should be.
  var i = this.stack.length-1;
  var node;
  var msg;
  // A full AST is always:
  // Program, Markup, MarkupContent, ...
  while(i &#x3e;= 2) {
    node = this.stack[i];
    if (node.endOk &#x26;&#x26; !node.endOk()) {
      // Attempt to make the error readable
      delete node.values;
      msg = &#x27;Found unclosed &#x27; + node.type;
      var err = new Error(msg);
      err.name = &#x27;UnclosedNodeError&#x27;;
      throw this.decorateError(
        err,
        node.startloc.line,
        node.startloc.column);
    }
    i--;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tokens = l.read();

var p = new Parser(opts);
p.write(tokens);
var more = true;
while(more !== null) more = p.read();

p.<span class="apidocCodeKeywordSpan">checkStack</span>();

// Stash the original input (new lines normalized by the lexer).
opts.source = l.originalInput;

p.lg(p.dumpAST());

var compiled = codegen(p.stack[0], opts);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.closeNode" id="apidoc.element.vash.parser.prototype.closeNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>closeNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeNode = function (node) {
  var toClose = this.stack[this.stack.length-1];
  if (node !== toClose) {
    var msg = &#x27;InvalidCloseAction: &#x27;
      + &#x27;Expected &#x27; + node.type + &#x27; in stack, instead found &#x27;
      + toClose.type;
    throw new Error(msg);
  }

  this.stack.pop();
  var last = this.stack[this.stack.length-1];

  this.lg(&#x27;Closing node %s (%s), returning to node %s&#x27;,
    node.type, node.name, last.type)

  this.node = last;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  updateLoc(node, curr);
  return true;
}

if (curr.type === node._waitingForClose) {
  this.flag(node, &#x27;_waitingForClose&#x27;, null)
  updateLoc(node, curr);
  this.<span class="apidocCodeKeywordSpan">closeNode</span>(node);
  return true;
}

if (curr.type === tks.DOUBLE_FORWARD_SLASH &#x26;&#x26; !node._waitingForClose){
  this.flag(node, &#x27;_waitingForClose&#x27;, tks.NEWLINE);
  updateLoc(node, curr);
  return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueBlockNode" id="apidoc.element.vash.parser.prototype.continueBlockNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueBlockNode
        <span class="apidocSignatureSpan">(node, curr, next, ahead, nnwon)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueBlockNode = function (node, curr, next, ahead, nnwon) {

  var valueNode = node.values[node.values.length-1];

  if (curr.type === tks.AT_STAR_OPEN) {
    this.openNode(new CommentNode(), node.body);
    return false;
  }

  if (curr.type === tks.DOUBLE_FORWARD_SLASH &#x26;&#x26; !node._waitingForEndQuote) {
    this.openNode(new CommentNode(), node.body);
    return false;
  }

  if (
    curr.type === tks.AT_COLON
    &#x26;&#x26; (!node.hasBraces || node._reachedOpenBrace)
  ) {
    valueNode = this.openNode(new MarkupContentNode(), node.values);
    return false;
  }

  if (
    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)
    &#x26;&#x26; !node._reachedOpenBrace
    &#x26;&#x26; !node.keyword
  ) {
    this.flag(node, &#x27;keyword&#x27;, curr.val);
    return true;
  }

  if (
    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)
    &#x26;&#x26; !node._reachedOpenBrace
  ) {
    // Assume something like if (test) expressionstatement;
    this.flag(node, &#x27;hasBraces&#x27;, false);
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (
    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)
    &#x26;&#x26; !node._reachedCloseBrace
    &#x26;&#x26; node.hasBraces
    &#x26;&#x26; !node._waitingForEndQuote
  ) {
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (
    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)
    &#x26;&#x26; node._reachedCloseBrace
    &#x26;&#x26; !node._waitingForEndQuote
  ) {
    valueNode = this.openNode(new BlockNode(), node.tail);
    updateLoc(valueNode, curr);
    return false;
  }

  if (
    curr.type === tks.BRACE_OPEN
    &#x26;&#x26; !node._reachedOpenBrace
    &#x26;&#x26; !node._waitingForEndQuote
  ) {
    this.flag(node, &#x27;_reachedOpenBrace&#x27;, true);
    this.flag(node, &#x27;hasBraces&#x27;, true);
    if (this.opts.favorText) {
      valueNode = this.openNode(new MarkupContentNode(), node.values);
      updateLoc(valueNode, curr);
    }
    return true;
  }

  if (
    curr.type === tks.BRACE_OPEN
    &#x26;&#x26; !node._waitingForEndQuote
  ) {
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (
    curr.type === tks.BRACE_CLOSE
    &#x26;&#x26; node.hasBraces
    &#x26;&#x26; !node._reachedCloseBrace
    &#x26;&#x26; !node._waitingForEndQuote
  ) {
    updateLoc(node, curr);
    this.flag(node, &#x27;_reachedCloseBrace&#x27;, true);

    // Try to leave whitespace where it belongs, and allow `else {` to
    // be continued as the tail of this block.
    if (
      nnwon
      &#x26;&#x26; nnwon.type !== tks.BLOCK_KEYWORD
    ) {
      this.closeNode(node);
    }

    return true;
  }

  if (
    curr.type === tks.BRACE_CLOSE
    &#x26;&#x26; !node.hasBraces
  ) {
    // Probably something like:
    // @{ if() &#x3c;span&#x3e;&#x3c;/span&#x3e; }
    this.closeNode(node);
    updateLoc(node, curr);
    return false;
  }

  if (
    curr.type === tks.LT_SIGN
    &#x26;&#x26; (next.type === tks.AT || next.type === tks.IDENTIFIER)
    &#x26;&#x26; !node._waitingForEndQuote
    &#x26;&#x26; node._reachedCloseBrace
  ) {
    this.closeNode(node);
    updateLoc(node, curr);
    return false;
  }

  if (
    curr.type === tks.LT_SIGN
    &#x26;&#x26; (next.type === tks.AT || next.type === tks.IDENTIFIER)
    &#x26;&#x26; !node._waitingForEndQuote
    &#x26;&#x26; !node._reachedCloseBrace
  ) {
    valueNode = this.openNode(new MarkupNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (curr.type === tks.HTML_TAG_CLOSE) {
    if (
      (node.hasBraces &#x26;&#x26; node._reachedCloseBrace)
      || !node._reachedOpenBrace
    ) {
      updateLoc(node, curr);
      this.closeNode(node);
      return false;
    }

    // This is likely an invalid markup configuration, something like:
    // @if(bla) { &#x3c;img&#x3e;&#x3c;/img&#x3e; }
    // where &#x3c;img&#x3e; is an implicit void. Try to help the user in this
    // specific case.
    if (
      next
      &#x26;&#x26; next.type === tks.IDENTIFIER
      &#x26;&#x26; MarkupNode.isVoid(next.val)
    ){
      throw newUnexpectedClosingTagError(this, curr, curr.val + next.val);
    }
  }

  if (
    curr.type === tks.AT
    &#x26;&#x26; (next.type === tks.BLOCK_KEYWORD
      || next.type === tks.BRACE_OPEN
      | ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueCommentNode" id="apidoc.element.vash.parser.prototype.continueCommentNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueCommentNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueCommentNode = function (node, curr, next) {
  var valueNode = ensureTextNode(node.values);

  if (curr.type === tks.AT_STAR_OPEN &#x26;&#x26; !node._waitingForClose) {
    this.flag(node, &#x27;_waitingForClose&#x27;, tks.AT_STAR_CLOSE)
    updateLoc(node, curr);
    return true;
  }

  if (curr.type === node._waitingForClose) {
    this.flag(node, &#x27;_waitingForClose&#x27;, null)
    updateLoc(node, curr);
    this.closeNode(node);
    return true;
  }

  if (curr.type === tks.DOUBLE_FORWARD_SLASH &#x26;&#x26; !node._waitingForClose){
    this.flag(node, &#x27;_waitingForClose&#x27;, tks.NEWLINE);
    updateLoc(node, curr);
    return true;
  }

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueExplicitExpressionNode" id="apidoc.element.vash.parser.prototype.continueExplicitExpressionNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueExplicitExpressionNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueExplicitExpressionNode = function (node, curr, next) {

  var valueNode = node.values[node.values.length-1];

  if (
    node.values.length === 0
    &#x26;&#x26; (curr.type === tks.AT || curr.type === tks.PAREN_OPEN)
  ) {
    // This is the beginning of the explicit (mark as consumed)
    this.flag(node, &#x27;_waitingForParenClose&#x27;, true);
    updateLoc(node, curr);
    return true;
  }

  if (curr.type === tks.PAREN_OPEN &#x26;&#x26; !node._waitingForEndQuote) {
    // New explicit expression
    valueNode = this.openNode(new ExplicitExpressionNode(), node.values);
    updateLoc(valueNode, curr);
    // And do nothing with the token (mark as consumed)
    return true;
  }

  if (curr.type === tks.PAREN_CLOSE &#x26;&#x26; !node._waitingForEndQuote) {
    // Close current explicit expression
    this.flag(node, &#x27;_waitingForParenClose&#x27;, false);
    updateLoc(node, curr);
    this.closeNode(node);
    // And do nothing with the token (mark as consumed)
    return true;
  }

  if (curr.type === tks.FUNCTION &#x26;&#x26; !node._waitingForEndQuote) {
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (
    curr.type === tks.LT_SIGN
    &#x26;&#x26; next.type === tks.IDENTIFIER
    &#x26;&#x26; !node._waitingForEndQuote
  ) {
    // Markup within expression
    valueNode = this.openNode(new MarkupNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  var pnw = this.previousNonWhitespace;

  if (
    curr.type === tks.FORWARD_SLASH
    &#x26;&#x26; !node._waitingForEndQuote
    &#x26;&#x26; pnw
    &#x26;&#x26; pnw.type !== tks.IDENTIFIER
    &#x26;&#x26; pnw.type !== tks.NUMERAL
    &#x26;&#x26; pnw.type !== tks.PAREN_CLOSE
  ) {
    valueNode = this.openNode(new RegexNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  // Default
  valueNode = ensureTextNode(node.values);

  if (
    !node._waitingForEndQuote
    &#x26;&#x26; (curr.type === tks.SINGLE_QUOTE || curr.type === tks.DOUBLE_QUOTE)
  ) {
    this.flag(node, &#x27;_waitingForEndQuote&#x27;, curr.val);
    appendTextValue(valueNode, curr);
    return true;
  }

  if (
    curr.val === node._waitingForEndQuote
    &#x26;&#x26; !curr._considerEscaped
  ) {
    this.flag(node, &#x27;_waitingForEndQuote&#x27;, null);
    appendTextValue(valueNode, curr);
    return true;
  }

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueExpressionNode" id="apidoc.element.vash.parser.prototype.continueExpressionNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueExpressionNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueExpressionNode = function (node, curr, next) {
  var valueNode = node.values[node.values.length-1];
  var pnw = this.previousNonWhitespace;

  if (
    curr.type === tks.AT
    &#x26;&#x26; next.type === tks.HARD_PAREN_OPEN
  ) {
    // LEGACY: @[], which means a legacy escape to content.
    updateLoc(node, curr);
    this.closeNode(node);
    return true;
  }

  if (curr.type === tks.PAREN_OPEN) {
    this.openNode(new ExplicitExpressionNode(), node.values);
    return false;
  }

  if (
    curr.type === tks.HARD_PAREN_OPEN
    &#x26;&#x26; node.values[0]
    &#x26;&#x26; node.values[0].type === &#x27;VashExplicitExpression&#x27;
  ) {
    // @()[0], hard parens should be content
    updateLoc(node, curr);
    this.closeNode(node);
    return false;
  }

  if (
    curr.type === tks.HARD_PAREN_OPEN
    &#x26;&#x26; next.type === tks.HARD_PAREN_CLOSE
  ) {
    // [], empty index should be content (php forms...)
    updateLoc(node, curr);
    this.closeNode(node);
    return false;
  }

  if (curr.type === tks.HARD_PAREN_OPEN) {
    this.openNode(new IndexExpressionNode(), node.values);
    return false;
  }

  if (
    curr.type === tks.FORWARD_SLASH
    &#x26;&#x26; pnw
    &#x26;&#x26; pnw.type === tks.AT
  ) {
    this.openNode(new RegexNode(), node.values)
    return false;
  }

  // Default
  // Consume only specific cases, otherwise close.

  if (curr.type === tks.PERIOD &#x26;&#x26; next &#x26;&#x26; next.type === tks.IDENTIFIER) {
    valueNode = ensureTextNode(node.values);
    appendTextValue(valueNode, curr);
    return true;
  }

  if (curr.type === tks.IDENTIFIER) {

    if (node.values.length &#x3e; 0 &#x26;&#x26; valueNode &#x26;&#x26; valueNode.type !== &#x27;VashText&#x27;) {
      // Assume we just ended an explicit expression.
      this.closeNode(node);
      return false;
    }

    valueNode = ensureTextNode(node.values);
    appendTextValue(valueNode, curr);
    return true;
  } else {
    this.closeNode(node);
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueIndexExpressionNode" id="apidoc.element.vash.parser.prototype.continueIndexExpressionNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueIndexExpressionNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueIndexExpressionNode = function (node, curr, next) {
  var valueNode = node.values[node.values.length-1];

  if (node._waitingForEndQuote) {
    if (curr.val === node._waitingForEndQuote) {
      this.flag(node, &#x27;_waitingForEndQuote&#x27;, null);
    }

    appendTextValue(valueNode, curr);
    return true;
  }

  if (
    curr.type === tks.HARD_PAREN_OPEN
    &#x26;&#x26; !valueNode
  ) {
    this.flag(node, &#x27;_waitingForHardParenClose&#x27;, true);
    updateLoc(node, curr);
    return true;
  }

  if (curr.type === tks.HARD_PAREN_CLOSE) {
    this.flag(node, &#x27;_waitingForHardParenClose&#x27;, false);
    this.closeNode(node);
    updateLoc(node, curr);
    return true;
  }

  if (curr.type === tks.PAREN_OPEN) {
    valueNode = this.openNode(new ExplicitExpressionNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  valueNode = ensureTextNode(node.values);

  if (!node._waitingForEndQuote
    &#x26;&#x26; (curr.type === tks.DOUBLE_QUOTE
    || curr.type === tks.SINGLE_QUOTE)
  ) {
    this.flag(node, &#x27;_waitingForEndQuote&#x27;, curr.val);
    appendTextValue(valueNode, curr);
    return true;
  }

  // Default.

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueMarkupAttributeNode" id="apidoc.element.vash.parser.prototype.continueMarkupAttributeNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupAttributeNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueMarkupAttributeNode = function (node, curr, next) {

  var valueNode;

  if (
    curr.type === tks.AT
    &#x26;&#x26; !curr._considerEscaped
    &#x26;&#x26; next
    &#x26;&#x26; next.type === tks.AT
  ) {
    next._considerEscaped = true;
    return true;
  }

  if (curr.type === tks.AT &#x26;&#x26; !curr._considerEscaped) {
    // To expression

    valueNode = this.openNode(new ExpressionNode(), !node._finishedLeft
      ? node.left
      : node.right);

    updateLoc(valueNode, curr);
    return true;
  }

  // End of left, value only
  if (
    !node._expectRight
    &#x26;&#x26; (curr.type === tks.WHITESPACE
      || curr.type === tks.GT_SIGN
      || curr.type === tks.HTML_TAG_VOID_CLOSE)
  ) {
    this.flag(node, &#x27;_finishedLeft&#x27;, true);
    updateLoc(node, curr);
    this.closeNode(node);
    return false; // defer
  }

  // End of left.
  if (curr.type === tks.EQUAL_SIGN &#x26;&#x26; !node._finishedLeft) {
    this.flag(node, &#x27;_finishedLeft&#x27;, true);
    this.flag(node, &#x27;_expectRight&#x27;, true);
    return true;
  }

  // Beginning of quoted value.
  if (
    node._expectRight
    &#x26;&#x26; !node.rightIsQuoted
    &#x26;&#x26; (curr.type === tks.DOUBLE_QUOTE
    || curr.type === tks.SINGLE_QUOTE)
  ) {
    this.flag(node, &#x27;rightIsQuoted&#x27;, curr.val);
    return true;
  }

  // End of quoted value.
  if (node.rightIsQuoted === curr.val) {
    updateLoc(node, curr);
    this.closeNode(node);
    return true;
  }

  // Default

  if (!node._finishedLeft) {
    valueNode = ensureTextNode(node.left);
  } else {
    valueNode = ensureTextNode(node.right);
  }

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueMarkupCommentNode" id="apidoc.element.vash.parser.prototype.continueMarkupCommentNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupCommentNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueMarkupCommentNode = function (node, curr, next) {
  var valueNode = node.values[node.values.length-1];

  if (curr.type === tks.HTML_COMMENT_OPEN) {
    this.flag(node, &#x27;_finishedOpen&#x27;, true);
    this.flag(node, &#x27;_waitingForClose&#x27;, tks.HTML_COMMENT_CLOSE);
    updateLoc(node, curr);
    valueNode = this.openNode(new MarkupContentNode(), node.values);
    return true;
  }

  if (curr.type === tks.HTML_COMMENT_CLOSE &#x26;&#x26; node._finishedOpen) {
    this.flag(node, &#x27;_waitingForClose&#x27;, null);
    updateLoc(node, curr);
    this.closeNode(node);
    return true;
  }

  valueNode = ensureTextNode(node.values);
  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueMarkupContentNode" id="apidoc.element.vash.parser.prototype.continueMarkupContentNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupContentNode
        <span class="apidocSignatureSpan">(node, curr, next, ahead)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueMarkupContentNode = function (node, curr, next, ahead) {
  var valueNode = ensureTextNode(node.values);

  if (curr.type === tks.HTML_COMMENT_OPEN) {
    valueNode = this.openNode(new MarkupCommentNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (curr.type === tks.HTML_COMMENT_CLOSE) {
    updateLoc(node, curr);
    this.closeNode(node);
    return false;
  }

  if (curr.type === tks.AT_COLON &#x26;&#x26; !curr._considerEscaped) {
    this.flag(node, &#x27;_waitingForNewline&#x27;, true);
    updateLoc(valueNode, curr);
    return true;
  }

  if (curr.type === tks.NEWLINE &#x26;&#x26; node._waitingForNewline === true) {
    this.flag(node, &#x27;_waitingForNewline&#x27;, false);
    appendTextValue(valueNode, curr);
    updateLoc(node, curr);
    this.closeNode(node);
    return true;
  }

  if (
    curr.type === tks.AT
    &#x26;&#x26; !curr._considerEscaped
    &#x26;&#x26; next.type === tks.BRACE_OPEN
  ) {
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return true;
  }

  if (
    curr.type === tks.AT
    &#x26;&#x26; !curr._considerEscaped
    &#x26;&#x26; (next.type === tks.BLOCK_KEYWORD
      || next.type === tks.FUNCTION)
  ) {
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return true;
  }

  // Mark @@: or @@ as escaped.
  if (
    curr.type === tks.AT
    &#x26;&#x26; !curr._considerEscaped
    &#x26;&#x26; next
    &#x26;&#x26; (
      next.type === tks.AT_COLON
      || next.type === tks.AT
      || next.type === tks.AT_STAR_OPEN
    )
  ) {
    next._considerEscaped = true;
    return true;
  }

  // @something
  if (curr.type === tks.AT &#x26;&#x26; !curr._considerEscaped) {
    valueNode = this.openNode(new ExpressionNode(), node.values);
    updateLoc(valueNode, curr);
    return true;
  }

  if (curr.type === tks.AT_STAR_OPEN &#x26;&#x26; !curr._considerEscaped) {
    this.openNode(new CommentNode(), node.values);
    return false;
  }

  var parent = this.stack[this.stack.length-2];

  // If this MarkupContent is the direct child of a block, it has no way to
  // know when to close. So in this case it should assume a } means it&#x27;s
  // done. Or if it finds a closing html tag, of course.
  if (
    curr.type === tks.HTML_TAG_CLOSE
    || (curr.type === tks.BRACE_CLOSE
      &#x26;&#x26; parent &#x26;&#x26; parent.type === &#x27;VashBlock&#x27;)
  ) {
    this.closeNode(node);
    updateLoc(node, curr);
    return false;
  }

  if (
    curr.type === tks.LT_SIGN
    &#x26;&#x26; next
    &#x26;&#x26; (
      // If next is an IDENTIFIER, then try to ensure that it&#x27;s likely an HTML
      // tag, which really can only be something like:
      // &#x3c;identifier&#x3e;
      // &#x3c;identifer morestuff (whitespace)
      // &#x3c;identifier\n
      // &#x3c;identifier@
      // &#x3c;identifier-
      // &#x3c;identifier:identifier // XML namespaces etc etc
      (next.type === tks.IDENTIFIER
        &#x26;&#x26; ahead
        &#x26;&#x26; (
          ahead.type === tks.GT_SIGN
          || ahead.type === tks.WHITESPACE
          || ahead.type === tks.NEWLINE
          || ahead.type === tks.AT
          || ahead.type === tks.UNARY_OPERATOR
          || ahead.type === tks.COLON
        )
      )
      || next.type === tks.AT)
  ) {
    // TODO: possibly check for same tag name, and if HTML5 incompatible,
    // such as p within p, then close current.
    valueNode = this.openNode(new MarkupNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  // Ignore whitespace if the direct parent is a block. This is for backwards
  // compatibility with { @what() }, where the &#x27; &#x27; between ) and } should not
  // be included as content. This rule should not be followed if the
  // whitespace is contained within an @: escape or within favorText mode.
  if (
    curr.type === tks.WHITESPACE
    &#x26;&#x26; !node._waitingForNewline
    &#x26;&#x26; !this.opts.favorText
    &#x26;&#x26; parent
    &#x26;&#x26; parent.type === &#x27;VashBlock&#x27;
  ) {
    return true;
  }

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueMarkupNode" id="apidoc.element.vash.parser.prototype.continueMarkupNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueMarkupNode = function (node, curr, next) {
  var valueNode = node.values[node.values.length-1];

  if (curr.type === tks.LT_SIGN &#x26;&#x26; !node._finishedOpen) {
    updateLoc(node, curr);
    return true;
  }

  if (
    !node._finishedOpen
    &#x26;&#x26; curr.type !== tks.GT_SIGN
    &#x26;&#x26; curr.type !== tks.LT_SIGN
    &#x26;&#x26; curr.type !== tks.WHITESPACE
    &#x26;&#x26; curr.type !== tks.NEWLINE
    &#x26;&#x26; curr.type !== tks.HTML_TAG_VOID_CLOSE
  ) {

    // Assume tag name

    if (
      curr.type === tks.AT
      &#x26;&#x26; !curr._considerEscaped
      &#x26;&#x26; next
      &#x26;&#x26; next.type === tks.AT
    ) {
      next._considerEscaped = true;
      return true;
    }

    if (curr.type === tks.AT &#x26;&#x26; !curr._considerEscaped) {
      this.flag(node, &#x27;expression&#x27;, this.openNode(new ExpressionNode()));
      updateLoc(node.expression, curr);
      return true;
    }

    node.name = node.name
      ? node.name + curr.val
      : curr.val;
    updateLoc(node, curr);
    return true;
  }

  if (curr.type === tks.GT_SIGN &#x26;&#x26; !node._waitingForFinishedClose) {
    this.flag(node, &#x27;_finishedOpen&#x27;, true);

    if (MarkupNode.isVoid(node.name)) {
      this.flag(node, &#x27;isVoid&#x27;, true);
      this.closeNode(node);
      updateLoc(node, curr);
    } else {
      valueNode = this.openNode(new MarkupContentNode(), node.values);
      updateLoc(valueNode, curr);
    }

    return true;
  }

  if (curr.type === tks.GT_SIGN &#x26;&#x26; node._waitingForFinishedClose) {
    this.flag(node, &#x27;_waitingForFinishedClose&#x27;, false);
    this.closeNode(node);
    updateLoc(node, curr);
    return true;
  }

  // &#x3c;/VOID
  if (
    curr.type === tks.HTML_TAG_CLOSE
    &#x26;&#x26; next
    &#x26;&#x26; next.type === tks.IDENTIFIER
    &#x26;&#x26; MarkupNode.isVoid(next.val)
  ) {
    throw newUnexpectedClosingTagError(this, curr, curr.val + next.val);
  }

  // &#x3c;/
  if (curr.type === tks.HTML_TAG_CLOSE) {
    this.flag(node, &#x27;_waitingForFinishedClose&#x27;, true);
    this.flag(node, &#x27;isClosed&#x27;, true);
    return true;
  }

  // --&#x3e;
  if (curr.type === tks.HTML_COMMENT_CLOSE) {
    this.flag(node, &#x27;_waitingForFinishedClose&#x27;, false);
    this.closeNode(node);
    return false;
  }

  if (curr.type === tks.HTML_TAG_VOID_CLOSE) {
    this.closeNode(node);
    this.flag(node, &#x27;isVoid&#x27;, true);
    this.flag(node, &#x27;voidClosed&#x27;, true);
    this.flag(node, &#x27;isClosed&#x27;, true);
    updateLoc(node, curr);
    return true;
  }

  if (node._waitingForFinishedClose) {
    this.lg(&#x27;Ignoring %s while waiting for closing GT_SIGN&#x27;,
      curr);
    return true;
  }

  if (
    (curr.type === tks.WHITESPACE || curr.type === tks.NEWLINE)
    &#x26;&#x26; !node._finishedOpen
    &#x26;&#x26; next.type !== tks.HTML_TAG_VOID_CLOSE
    &#x26;&#x26; next.type !== tks.GT_SIGN
    &#x26;&#x26; next.type !== tks.NEWLINE
    &#x26;&#x26; next.type !== tks.WHITESPACE
  ) {
    // enter attribute
    valueNode = this.openNode(new MarkupAttributeNode(), node.attributes);
    updateLoc(valueNode, curr);
    return true;
  }

  // Whitespace between attributes should be ignored.
  if (
    (curr.type === tks.WHITESPACE || curr.type === tks.NEWLINE)
    &#x26;&#x26; !node._finishedOpen
  ) {
    updateLoc(node, curr);
    return true;
  }

  // Can&#x27;t really have non-markupcontent within markup, so implicitly open
  // a node. #68.
  if (node._finishedOpen) {
    valueNode = this.openNode(new MarkupContentNode(), this.node.values);
    updateLoc(valueNode, curr);
    return false; // defer
  }

  // Default

  //valueNode = ensureTextNode(node.values);
  //appendTextValue(valueNode, curr);
  //return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueRegexNode" id="apidoc.element.vash.parser.prototype.continueRegexNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueRegexNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueRegexNode = function (node, curr, next) {
  var valueNode = ensureTextNode(node.values);

  if (
    curr.type === tks.FORWARD_SLASH
    &#x26;&#x26; !node._waitingForForwardSlash
    &#x26;&#x26; !curr._considerEscaped
  ) {
    // Start of regex.
    this.flag(node, &#x27;_waitingForForwardSlash&#x27;, true);
    appendTextValue(valueNode, curr);
    return true;
  }

  if (
    curr.type === tks.FORWARD_SLASH
    &#x26;&#x26; node._waitingForForwardSlash
    &#x26;&#x26; !curr._considerEscaped
  ) {
    // &#x22;End&#x22; of regex.
    this.flag(node, &#x27;_waitingForForwardSlash&#x27;, null);
    this.flag(node, &#x27;_waitingForFlags&#x27;, true);
    appendTextValue(valueNode, curr);
    return true;
  }

  if (node._waitingForFlags) {
    this.flag(node, &#x27;_waitingForFlags&#x27;, null);
    this.closeNode(node);

    if (curr.type === tks.IDENTIFIER) {
      appendTextValue(valueNode, curr);
      return true;
    } else {
      return false;
    }
  }

  if (
    curr.type === tks.BACKSLASH
    &#x26;&#x26; !curr._considerEscaped
  ) {
    next._considerEscaped = true;
  }

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.decorateError" id="apidoc.element.vash.parser.prototype.decorateError">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>decorateError
        <span class="apidocSignatureSpan">(err, line, column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorateError = function (err, line, column) {
  err.message = &#x27;&#x27;
    + err.message
    + &#x27; at template line &#x27; + line
    + &#x27;, column &#x27; + column + &#x27;\n\n&#x27;
    + &#x27;Context: \n&#x27;
    + error.context(this.inputText, line, column, &#x27;\n&#x27;)
    + &#x27;\n&#x27;;

  return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    node = this.stack[i];
    if (node.endOk &#x26;&#x26; !node.endOk()) {
      // Attempt to make the error readable
      delete node.values;
      msg = &#x27;Found unclosed &#x27; + node.type;
      var err = new Error(msg);
      err.name = &#x27;UnclosedNodeError&#x27;;
      throw this.<span class="apidocCodeKeywordSpan">decorateError</span>(
        err,
        node.startloc.line,
        node.startloc.column);
    }
    i--;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.dumpAST" id="apidoc.element.vash.parser.prototype.dumpAST">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>dumpAST
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dumpAST = function () {
  if (!this.stack.length) {
    var msg = &#x27;No AST to dump.&#x27;;
    throw new Error(msg);
  }

  return JSON.stringify(this.stack[0], null, &#x27;  &#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  while(more !== null) more = p.read();

  p.checkStack();

  // Stash the original input (new lines normalized by the lexer).
  opts.source = l.originalInput;

  p.lg(p.<span class="apidocCodeKeywordSpan">dumpAST</span>());

  var compiled = codegen(p.stack[0], opts);
  lg(compiled);
  var tpl = runtime.link(compiled, opts);

  return tpl;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.flag" id="apidoc.element.vash.parser.prototype.flag">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>flag
        <span class="apidocSignatureSpan">(node, name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flag = function (node, name, value) {
  var printVal = (value &#x26;&#x26; typeof value === &#x27;object&#x27;)
    ? value.type
    : value;
  this.lg(&#x27;Flag %s on node %s was %s now %s&#x27;,
    name, node.type, node[name], printVal);
  node[name] = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.node = last;
}

Parser.prototype.continueCommentNode = function(node, curr, next) {
var valueNode = ensureTextNode(node.values);

if (curr.type === tks.AT_STAR_OPEN &#x26;&#x26; !node._waitingForClose) {
  this.<span class="apidocCodeKeywordSpan">flag</span>(node, &#x27;_waitingForClose&#x27;, tks.AT_STAR_CLOSE)
  updateLoc(node, curr);
  return true;
}

if (curr.type === node._waitingForClose) {
  this.flag(node, &#x27;_waitingForClose&#x27;, null)
  updateLoc(node, curr);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.openNode" id="apidoc.element.vash.parser.prototype.openNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>openNode
        <span class="apidocSignatureSpan">(node, opt_insertArr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openNode = function (node, opt_insertArr) {
  this.stack.push(node);
  this.lg(&#x27;Opened node %s from %s&#x27;,
    node.type, (this.node ? this.node.type : null));
  this.node = node;

  if (opt_insertArr) {
    opt_insertArr.push(node);
  }

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.tokens.unshift.apply(this.tokens, tokens.reverse());
}

Parser.prototype.read = function() {
if (!this.tokens.length &#x26;&#x26; !this.deferredTokens.length) return null;

if (!this.node) {
  this.<span class="apidocCodeKeywordSpan">openNode</span>(new ProgramNode());
  this.openNode(new MarkupNode(), this.node.body);
  this.node._finishedOpen = true;
  this.node.name = &#x27;text&#x27;;
  updateLoc(this.node, { line: 0, chr: 0 })
  this.openNode(new MarkupContentNode(), this.node.values);
  updateLoc(this.node, { line: 0, chr: 0 })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.read" id="apidoc.element.vash.parser.prototype.read">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {
  if (!this.tokens.length &#x26;&#x26; !this.deferredTokens.length) return null;

  if (!this.node) {
    this.openNode(new ProgramNode());
    this.openNode(new MarkupNode(), this.node.body);
    this.node._finishedOpen = true;
    this.node.name = &#x27;text&#x27;;
    updateLoc(this.node, { line: 0, chr: 0 })
    this.openNode(new MarkupContentNode(), this.node.values);
    updateLoc(this.node, { line: 0, chr: 0 })
  }

  var curr = this.deferredTokens.pop() || this.tokens.pop();

  // To find this value we must search through both deferred and
  // non-deferred tokens, since there could be more than just 3
  // deferred tokens.
  // nextNonWhitespaceOrNewline
  var nnwon = null;

  for (var i = this.deferredTokens.length-1; i &#x3e;= 0; i--) {
    if (
      nnwon
      &#x26;&#x26; nnwon.type !== tks.WHITESPACE
      &#x26;&#x26; nnwon.type !== tks.NEWLINE
    ) break;
    nnwon = this.deferredTokens[i];
  }

  for (var i = this.tokens.length-1; i &#x3e;= 0; i--) {
    if (
      nnwon
      &#x26;&#x26; nnwon.type !== tks.WHITESPACE
      &#x26;&#x26; nnwon.type !== tks.NEWLINE
    ) break;
    nnwon = this.tokens[i];
  }

  var next = this.deferredTokens.pop() || this.tokens.pop();
  var ahead = this.deferredTokens.pop() || this.tokens.pop();

  var dispatch = &#x27;continue&#x27; + this.node.constructor.name;

  this.lg(&#x27;Read: %s&#x27;, dispatch);
  this.lg(&#x27;  curr %s&#x27;, curr);
  this.lg(&#x27;  next %s&#x27;, next);
  this.lg(&#x27;  ahead %s&#x27;, ahead);
  this.lg(&#x27;  nnwon %s&#x27;, nnwon);

  if (curr._considerEscaped) {
    this.lg(&#x27;  Previous token was marked as escaping&#x27;);
  }

  var consumed = this[dispatch](this.node, curr, next, ahead, nnwon);

  if (ahead) {
    // ahead may be undefined when about to run out of tokens.
    this.deferredTokens.push(ahead);
  }

  if (next) {
    // Next may be undefined when about to run out of tokens.
    this.deferredTokens.push(next);
  }

  if (!consumed) {
    this.lg(&#x27;Deferring curr %s&#x27;, curr);
    this.deferredTokens.push(curr);
  } else {

    if (curr.type !== tks.WHITESPACE) {
      this.lg(&#x27;set previousNonWhitespace %s&#x27;, curr);
      this.previousNonWhitespace = curr;
    }

    // Poor man&#x27;s ASI.
    if (curr.type === tks.NEWLINE) {
      this.lg(&#x27;set previousNonWhitespace %s&#x27;, null);
      this.previousNonWhitespace = null;
    }

    if (!curr._considerEscaped &#x26;&#x26; curr.type === tks.BACKSLASH) {
      next._considerEscaped = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var opts = copyrtl({}, exports.config, options || {});

var l = new Lexer();

l.write(markup);
var tokens = l.<span class="apidocCodeKeywordSpan">read</span>();

var p = new Parser(opts);
p.write(tokens);
var more = true;
while(more !== null) more = p.read();

p.checkStack();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.write" id="apidoc.element.vash.parser.prototype.write">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>write
        <span class="apidocSignatureSpan">(tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (tokens) {
  if (!Array.isArray(tokens)) tokens = [tokens];
  this.inputText += tokens.map(function(tok) { return tok.val; }).join(&#x27;&#x27;);
  this.tokens.unshift.apply(this.tokens, tokens.reverse());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error(&#x27;Empty or non-string cannot be compiled&#x27;);
}

var opts = copyrtl({}, exports.config, options || {});

var l = new Lexer();

l.<span class="apidocCodeKeywordSpan">write</span>(markup);
var tokens = l.read();

var p = new Parser(opts);
p.write(tokens);
var more = true;
while(more !== null) more = p.read();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.runtime" id="apidoc.module.vash.runtime">module vash.runtime</a></h1>


    <h2>
        <a href="#apidoc.element.vash.runtime.Mark" id="apidoc.element.vash.runtime.Mark">
        function <span class="apidocSignatureSpan">vash.runtime.</span>Mark
        <span class="apidocSignatureSpan">( buffer, debugName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Mark = function ( buffer, debugName ){
  this.uid = &#x27;[VASHMARK-&#x27;
    + ~~( Math.random() * 10000000 )
    + (debugName ? &#x27;:&#x27; + debugName : &#x27;&#x27;)
    + &#x27;]&#x27;;
  this.markedIndex = 0;
  this.buffer = buffer;
  this.destroyed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.runtime.install" id="apidoc.element.vash.runtime.install">
        function <span class="apidocSignatureSpan">vash.runtime.</span>install
        <span class="apidocSignatureSpan">( path, tpl )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function ( path, tpl ){
  var cache = runtime.helpers.tplcache;
  if( typeof tpl === &#x27;string&#x27; ){
    // Super hacky: if the calling context has a `compile` function,
    // then `this` is likely full vash. This is simply for backwards
    // compatibility.
    // TODO: @deprecate
    if ( typeof this.compile === &#x27;function&#x27;) {
      tpl = this.compile(tpl);
    } else {
      throw new Error(&#x27;.install(path, [string]) is not available in the standalone runtime.&#x27;);
    }
  } else if( typeof path === &#x27;object&#x27; ){
    tpl = path;
    Object.keys(tpl).forEach(function(path){
      cache[path] = tpl[path];
    });
    return cache;
  }
  return cache[path] = tpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If `model` is passed and the template is found, the template is automatically executed and returned using `model` as the model.

&#x3c;a name=&#x22;vash-install&#x22;&#x3e;&#x3c;/a&#x3e;vash.install
--------------------

`vash.install` accepts a few signatures:

	vash.<span class="apidocCodeKeywordSpan">install</span>(str_path, func_tpl) -&#x3e; func_tpl

&#x22;Saves&#x22; the template at `vash.helpers.tplcache[str_path]`.

	vash.install(str_path, str_tpl) -&#x3e; func_tpl

If `vash.compile` is available (meaning the entire compiler is available, not just the runtime), then the string is automatically
 compiled. and saved at `vash.helpers.tplcache[str_path]`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.runtime.link" id="apidoc.element.vash.runtime.link">
        function <span class="apidocSignatureSpan">vash.runtime.</span>link
        <span class="apidocSignatureSpan">( cmpFunc, options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function ( cmpFunc, options ){

  // TODO: allow options.filename to be used as sourceUrl?

  var  originalFunc
    ,cmpOpts;

  if( !options.args ){
    // every template has these arguments
    options.args = [options.modelName, options.helpersName, &#x27;__vopts&#x27;, &#x27;runtime&#x27;];
  }

  if( typeof cmpFunc === &#x27;string&#x27; ){
    originalFunc = cmpFunc;

    try {
      // do not pollute the args array for later attachment to the compiled
      // function for later decompilation/linking
      cmpOpts = options.args.slice();
      cmpOpts.push(cmpFunc);
      cmpFunc = Function.apply(null, cmpOpts);
    } catch(e) {
      // TODO: add flag to reportError to know if it&#x27;s at compile time or runtime
      helpers.reportError(e, 0, 0, originalFunc, /\n/, false);
    }
  }

  // need this to enable decompilation / relinking
  cmpFunc.options = {
     simple: options.simple
    ,modelName: options.modelName
    ,helpersName: options.helpersName
  }

  var linked;

  if( options.asHelper ){

    cmpFunc.options.args = options.args;
    cmpFunc.options.asHelper = options.asHelper;

    linked = function(){
      return cmpFunc.apply(this, slice.call(arguments));
    }

    helpers[options.asHelper] = linked;

  } else {

    linked = function( model, opts ){
      if( options.simple ){
        var ctx = {
           buffer: []
          ,escape: Helpers.prototype.escape
          ,raw: Helpers.prototype.raw
        }
        return cmpFunc( model, ctx, opts, runtime );
      }

      opts = divineRuntimeTplOptions( model, opts );
      return cmpFunc( model, (opts &#x26;&#x26; opts.context) || new Helpers( model ), opts, runtime );
    }
  }

  // show the template-specific code, instead of the generic linked function
  linked[&#x27;toString&#x27;] = function(){ return cmpFunc.toString(); }

  // shortcut to show the actual linked function
  linked[&#x27;_toString&#x27;] = function(){ return Function.prototype.toString.call(linked) }

  // This assumes a vash global, and should be deprecated.
  // TODO: @deprecate
  linked[&#x27;toClientString&#x27;] = function(){
    return &#x27;vash.link( &#x27;
      + cmpFunc.toString() + &#x27;, &#x27;
      + JSON.stringify( cmpFunc.options ) + &#x27; )&#x27;;
  }

  return linked;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		return (__vopts &#x26;&#x26; __vopts.asContext)
			? html
			: html.toString();
	}

If `toClientString` is called on that function, the following is returned:

	vash.<span class="apidocCodeKeywordSpan">link</span>( function anonymous(model,html,__vopts,vash) {
		var __vbuffer = html.buffer;
		html.options = __vopts;
		model = model || {};
		__vbuffer.push(&#x27;&#x3c;p&#x3e;&#x3c;/p&#x3e;\n&#x27;);
		(__vopts &#x26;&#x26; __vopts.onRenderEnd &#x26;&#x26; __vopts.onRenderEnd(null, html));
		return (__vopts &#x26;&#x26; __vopts.asContext)
			? html
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.runtime.lookup" id="apidoc.element.vash.runtime.lookup">
        function <span class="apidocSignatureSpan">vash.runtime.</span>lookup
        <span class="apidocSignatureSpan">( path, model )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function ( path, model ){
  var tpl = runtime.helpers.tplcache[path];
  if( !tpl ){ throw new Error(&#x27;Could not find template: &#x27; + path); }
  if( model ){ return tpl(model); }
  else return tpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This is primarily an internal function, and has relatively complex behavioral differences depending on what options are passed in
. It takes either a decompiled string function or function instance and &#x22;links&#x22; it by wrapping it in a closure that provides
 access to Vash&#x27;s runtime functions. It also sets up things like `toClientString` and `toString`. It makes precompiled functions
 possible. As a developer working on Vash, it&#x27;s best to take a look at the [source itself][].

[source itself]: https://github.com/kirbysayshi/vash/blob/master/src/vruntime.js

&#x3c;a name=&#x22;vash-lookup&#x22;&#x3e;&#x3c;/a&#x3e;vash.lookup
-------------------

	vash.<span class="apidocCodeKeywordSpan">lookup</span>(str_path) -&#x3e; Function

Attempts to grab a template from `vash.helpers.tplcache[str_path]`, and throws an exception if it is not found.

	vash.lookup(str_path, model) -&#x3e; Function

If `model` is passed and the template is found, the template is automatically executed and returned using `model` as the model.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.runtime.uninstall" id="apidoc.element.vash.runtime.uninstall">
        function <span class="apidocSignatureSpan">vash.runtime.</span>uninstall
        <span class="apidocSignatureSpan">( path )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function ( path ){
  var  cache = runtime.helpers.tplcache
    ,deleted = false;

  if( typeof path === &#x27;string&#x27; ){
    return delete cache[path];
  } else {
    Object.keys(cache).forEach(function(key){
      if( cache[key] === path ){ deleted = delete cache[key]; }
    })
    return deleted;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	vash.install(obj) -&#x3e; obj

If an object containing string keys pointing at template functions is passed, then the object&#x27;s keys are used as the keys for
 `vash.helpers.tplcache`. This is especially useful when using [vash.compileBatch][], as the result can be directly passed.

&#x3c;a name=&#x22;vash-uninstall&#x22;&#x3e;&#x3c;/a&#x3e;vash.uninstall
----------------------

	vash.<span class="apidocCodeKeywordSpan">uninstall</span>(str_path) -&#x3e; bool

Deletes the key named `str_path` from `vash.helpers.tplcache`.

	vash.uninstall(func_tpl) -&#x3e; bool

Loops through all templates in `vash.helpers.tplcache`, and if a strict equality is successful, deletes that reference.
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
