<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/kirbysayshi/vash">vash (v0.12.2)</a>
</h1>
<h4>Razor syntax for JS templating</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash">module vash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.Mark">
            function <span class="apidocSignatureSpan">vash.</span>Mark
            <span class="apidocSignatureSpan">( buffer, debugName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.__express">
            function <span class="apidocSignatureSpan">vash.</span>__express
            <span class="apidocSignatureSpan">(filepath, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.batch">
            function <span class="apidocSignatureSpan">vash.</span>batch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.compile">
            function <span class="apidocSignatureSpan">vash.</span>compile
            <span class="apidocSignatureSpan">(markup, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.compileBatch">
            function <span class="apidocSignatureSpan">vash.</span>compileBatch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.compileHelper">
            function <span class="apidocSignatureSpan">vash.</span>compileHelper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.compileStream">
            function <span class="apidocSignatureSpan">vash.</span>compileStream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.constructor">
            function <span class="apidocSignatureSpan">vash.</span>helpers.constructor
            <span class="apidocSignatureSpan">( model )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.install">
            function <span class="apidocSignatureSpan">vash.</span>install
            <span class="apidocSignatureSpan">( path, tpl )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer">
            function <span class="apidocSignatureSpan">vash.</span>lexer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.link">
            function <span class="apidocSignatureSpan">vash.</span>link
            <span class="apidocSignatureSpan">( cmpFunc, options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.loadFile">
            function <span class="apidocSignatureSpan">vash.</span>loadFile
            <span class="apidocSignatureSpan">(filepath, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lookup">
            function <span class="apidocSignatureSpan">vash.</span>lookup
            <span class="apidocSignatureSpan">( path, model )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser">
            function <span class="apidocSignatureSpan">vash.</span>parser
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.renderFile">
            function <span class="apidocSignatureSpan">vash.</span>renderFile
            <span class="apidocSignatureSpan">(filepath, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.uninstall">
            function <span class="apidocSignatureSpan">vash.</span>uninstall
            <span class="apidocSignatureSpan">( path )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>Mark.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>error</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>lexer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>nodestuff</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.</span>runtime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">vash.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.Mark">module vash.Mark</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.Mark.Mark">
            function <span class="apidocSignatureSpan">vash.</span>Mark
            <span class="apidocSignatureSpan">( buffer, debugName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.Mark.uidLike">
            function <span class="apidocSignatureSpan">vash.Mark.</span>uidLike
            <span class="apidocSignatureSpan">( str )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.Mark.</span>re</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.Mark.prototype">module vash.Mark.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.Mark.prototype.destroy">
            function <span class="apidocSignatureSpan">vash.Mark.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.Mark.prototype.findInBuffer">
            function <span class="apidocSignatureSpan">vash.Mark.prototype.</span>findInBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.error">module vash.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.error.context">
            function <span class="apidocSignatureSpan">vash.error.</span>context
            <span class="apidocSignatureSpan">(input, lineno, columnno, linebreak)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.helpers">module vash.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers._ensureLayoutProps">
            function <span class="apidocSignatureSpan">vash.helpers.</span>_ensureLayoutProps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers._handlePrependAppend">
            function <span class="apidocSignatureSpan">vash.helpers.</span>_handlePrependAppend
            <span class="apidocSignatureSpan">( type, name, ctn )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.append">
            function <span class="apidocSignatureSpan">vash.helpers.</span>append
            <span class="apidocSignatureSpan">(name, ctn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.block">
            function <span class="apidocSignatureSpan">vash.helpers.</span>block
            <span class="apidocSignatureSpan">(name, ctn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.constructor">
            function <span class="apidocSignatureSpan">vash.helpers.</span>constructor
            <span class="apidocSignatureSpan">( model )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.escape">
            function <span class="apidocSignatureSpan">vash.helpers.</span>escape
            <span class="apidocSignatureSpan">( val )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.extend">
            function <span class="apidocSignatureSpan">vash.helpers.</span>extend
            <span class="apidocSignatureSpan">(path, ctn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.finishLayout">
            function <span class="apidocSignatureSpan">vash.helpers.</span>finishLayout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.highlight">
            function <span class="apidocSignatureSpan">vash.helpers.</span>highlight
            <span class="apidocSignatureSpan">(lang, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.include">
            function <span class="apidocSignatureSpan">vash.helpers.</span>include
            <span class="apidocSignatureSpan">(name, model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.prepend">
            function <span class="apidocSignatureSpan">vash.helpers.</span>prepend
            <span class="apidocSignatureSpan">(name, ctn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.raw">
            function <span class="apidocSignatureSpan">vash.helpers.</span>raw
            <span class="apidocSignatureSpan">( val )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.reportError">
            function <span class="apidocSignatureSpan">vash.helpers.</span>reportError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.toHtmlString">
            function <span class="apidocSignatureSpan">vash.helpers.</span>toHtmlString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.toString">
            function <span class="apidocSignatureSpan">vash.helpers.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.trim">
            function <span class="apidocSignatureSpan">vash.helpers.</span>trim
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.helpers.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.helpers.</span>tplcache</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.helpers.constructor">module vash.helpers.constructor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.constructor.constructor">
            function <span class="apidocSignatureSpan">vash.helpers.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.helpers.constructor.reportError">
            function <span class="apidocSignatureSpan">vash.helpers.constructor.</span>reportError
            <span class="apidocSignatureSpan">(e, lineno, chr, orig, lb, atRenderTime)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.lexer">module vash.lexer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer.lexer">
            function <span class="apidocSignatureSpan">vash.</span>lexer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.lexer.prototype">module vash.lexer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer.prototype.advance">
            function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>advance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer.prototype.read">
            function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer.prototype.scan">
            function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>scan
            <span class="apidocSignatureSpan">(regexp, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.lexer.prototype.write">
            function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>write
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.nodestuff">module vash.nodestuff</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.nodestuff.clean">
            function <span class="apidocSignatureSpan">vash.nodestuff.</span>clean
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.parser">module vash.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.parser">
            function <span class="apidocSignatureSpan">vash.</span>parser
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.parser.prototype">module vash.parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.checkStack">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>checkStack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.closeNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>closeNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueBlockNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueBlockNode
            <span class="apidocSignatureSpan">(node, curr, next, ahead, nnwon)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueCommentNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueCommentNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueExplicitExpressionNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueExplicitExpressionNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueExpressionNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueExpressionNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueIndexExpressionNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueIndexExpressionNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueMarkupAttributeNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupAttributeNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueMarkupCommentNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupCommentNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueMarkupContentNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupContentNode
            <span class="apidocSignatureSpan">(node, curr, next, ahead)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueMarkupNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.continueRegexNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueRegexNode
            <span class="apidocSignatureSpan">(node, curr, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.decorateError">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>decorateError
            <span class="apidocSignatureSpan">(err, line, column)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.dumpAST">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>dumpAST
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.flag">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>flag
            <span class="apidocSignatureSpan">(node, name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.openNode">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>openNode
            <span class="apidocSignatureSpan">(node, opt_insertArr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.read">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.parser.prototype.write">
            function <span class="apidocSignatureSpan">vash.parser.prototype.</span>write
            <span class="apidocSignatureSpan">(tokens)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.vash.runtime">module vash.runtime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.runtime.Mark">
            function <span class="apidocSignatureSpan">vash.runtime.</span>Mark
            <span class="apidocSignatureSpan">( buffer, debugName )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.runtime.install">
            function <span class="apidocSignatureSpan">vash.runtime.</span>install
            <span class="apidocSignatureSpan">( path, tpl )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.runtime.link">
            function <span class="apidocSignatureSpan">vash.runtime.</span>link
            <span class="apidocSignatureSpan">( cmpFunc, options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.runtime.lookup">
            function <span class="apidocSignatureSpan">vash.runtime.</span>lookup
            <span class="apidocSignatureSpan">( path, model )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vash.runtime.uninstall">
            function <span class="apidocSignatureSpan">vash.runtime.</span>uninstall
            <span class="apidocSignatureSpan">( path )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">vash.runtime.</span>helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">vash.runtime.</span>version</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash" id="apidoc.module.vash">module vash</a></h1>


    <h2>
        <a href="#apidoc.element.vash.Mark" id="apidoc.element.vash.Mark">
        function <span class="apidocSignatureSpan">vash.</span>Mark
        <span class="apidocSignatureSpan">( buffer, debugName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Mark = function ( buffer, debugName ){
  this.uid = '[VASHMARK-'
    + ~~( Math.random() * 10000000 )
    + (debugName ? ':' + debugName : '')
    + ']';
  this.markedIndex = 0;
  this.buffer = buffer;
  this.destroyed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.__express" id="apidoc.element.vash.__express">
        function <span class="apidocSignatureSpan">vash.</span>__express
        <span class="apidocSignatureSpan">(filepath, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__express = function (filepath, options, cb){

  vash.loadFile(filepath, options, function(err, tpl){
    // auto setup an `onRenderEnd` callback to seal the layout
    var prevORE = options.onRenderEnd;

    cb( err, !err &amp;&amp; tpl(options, function(err, ctx){
      ctx.finishLayout()
      if( prevORE ) prevORE(err, ctx);
    }) );
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.batch" id="apidoc.element.vash.batch">
        function <span class="apidocSignatureSpan">vash.</span>batch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">batch = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.compile" id="apidoc.element.vash.compile">
        function <span class="apidocSignatureSpan">vash.</span>compile
        <span class="apidocSignatureSpan">(markup, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (markup, options) {

  if(markup === '' || typeof markup !== 'string') {
    throw new Error('Empty or non-string cannot be compiled');
  }

  var opts = copyrtl({}, exports.config, options || {});

  var l = new Lexer();

  l.write(markup);
  var tokens = l.read();

  var p = new Parser(opts);
  p.write(tokens);
  var more = true;
  while(more !== null) more = p.read();

  p.checkStack();

  // Stash the original input (new lines normalized by the lexer).
  opts.source = l.originalInput;

  p.lg(p.dumpAST());

  var compiled = codegen(p.stack[0], opts);
  lg(compiled);
  var tpl = runtime.link(compiled, opts);

  return tpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&lt;a name="quick-start"&gt;&lt;/a&gt;Quick Start
===================

&lt;a name="nodejs"&gt;&lt;/a&gt;nodejs
--------------

	var vash = require('vash');
	var tpl = vash.<span class="apidocCodeKeywordSpan">compile</span>('&lt;p&gt;I am a @model.t!&lt;/p&gt;');

	var out = tpl({ t: 'template' });
	// &lt;p&gt;I am a template!&lt;/p&gt;

&lt;a name="express"&gt;&lt;/a&gt;express
--------------------
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.compileBatch" id="apidoc.element.vash.compileBatch">
        function <span class="apidocSignatureSpan">vash.</span>compileBatch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileBatch = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	vash.compileHelper(str_template, opt_options) -&gt; Object

See [Compiled Helpers][] for more detail.

&lt;a name="vash-compilebatch"&gt;&lt;/a&gt;vash.compileBatch
----------------------------------------------------

	vash.<span class="apidocCodeKeywordSpan">compileBatch</span>(str_template, opt_options) -&gt; Object

This function can take a single string containing many named templates, and output an object containing the compiled versions of
 those templates. A "named template" is of the form (similar to a `sourceURL`):

	//@batch = div
	&lt;div&gt;@model&lt;/div&gt;\n'

	//@batch = a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.compileHelper" id="apidoc.element.vash.compileHelper">
        function <span class="apidocSignatureSpan">vash.</span>compileHelper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileHelper = function () { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	vash.compile(str_template, opt_options) -&gt; Function

At its core, Vash has a `compile` function that accepts a string and options, and returns a function, otherwise known as a compiled
 template. That function, when called with a parameter (otherwise known as a _model_), will use that parameter to fill in the template
. A model can be any value, including `undefined`, objects, arrays, strings, and booleans.

&lt;a name="vash-compilehelper"&gt;&lt;/a&gt;vash.compileHelper
-----------------------------------------------------

	vash.<span class="apidocCodeKeywordSpan">compileHelper</span>(str_template, opt_options) -&gt; Object

See [Compiled Helpers][] for more detail.

&lt;a name="vash-compilebatch"&gt;&lt;/a&gt;vash.compileBatch
----------------------------------------------------

	vash.compileBatch(str_template, opt_options) -&gt; Object
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.compileStream" id="apidoc.element.vash.compileStream">
        function <span class="apidocSignatureSpan">vash.</span>compileStream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compileStream = function () {
  // This could eventually handle waiting until a `null`
  // is pushed into the lexer, etc.
  throw new Error('NotImplemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.constructor" id="apidoc.element.vash.helpers.constructor">
        function <span class="apidocSignatureSpan">vash.</span>helpers.constructor
        <span class="apidocSignatureSpan">( model )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Helpers( model ) {
  this.buffer = new Buffer();
  this.model  = model;
  this.options = null; // added at render time

  this.vl = 0;
  this.vc = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.install" id="apidoc.element.vash.install">
        function <span class="apidocSignatureSpan">vash.</span>install
        <span class="apidocSignatureSpan">( path, tpl )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function ( path, tpl ){
  var cache = runtime.helpers.tplcache;
  if( typeof tpl === 'string' ){
    // Super hacky: if the calling context has a `compile` function,
    // then `this` is likely full vash. This is simply for backwards
    // compatibility.
    // TODO: @deprecate
    if ( typeof this.compile === 'function') {
      tpl = this.compile(tpl);
    } else {
      throw new Error('.install(path, [string]) is not available in the standalone runtime.');
    }
  } else if( typeof path === 'object' ){
    tpl = path;
    Object.keys(tpl).forEach(function(path){
      cache[path] = tpl[path];
    });
    return cache;
  }
  return cache[path] = tpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If `model` is passed and the template is found, the template is automatically executed and returned using `model` as the model.

&lt;a name="vash-install"&gt;&lt;/a&gt;vash.install
--------------------

`vash.install` accepts a few signatures:

	vash.<span class="apidocCodeKeywordSpan">install</span>(str_path, func_tpl) -&gt; func_tpl

"Saves" the template at `vash.helpers.tplcache[str_path]`.

	vash.install(str_path, str_tpl) -&gt; func_tpl

If `vash.compile` is available (meaning the entire compiler is available, not just the runtime), then the string is automatically
 compiled. and saved at `vash.helpers.tplcache[str_path]`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.lexer" id="apidoc.element.vash.lexer">
        function <span class="apidocSignatureSpan">vash.</span>lexer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VLexer(){
  this.lg = debug('vash:lexer');
  this.input = '';
  this.originalInput = '';
  this.lineno = 1;
  this.charno = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.link" id="apidoc.element.vash.link">
        function <span class="apidocSignatureSpan">vash.</span>link
        <span class="apidocSignatureSpan">( cmpFunc, options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function ( cmpFunc, options ){

  // TODO: allow options.filename to be used as sourceUrl?

  var  originalFunc
    ,cmpOpts;

  if( !options.args ){
    // every template has these arguments
    options.args = [options.modelName, options.helpersName, '__vopts', 'runtime'];
  }

  if( typeof cmpFunc === 'string' ){
    originalFunc = cmpFunc;

    try {
      // do not pollute the args array for later attachment to the compiled
      // function for later decompilation/linking
      cmpOpts = options.args.slice();
      cmpOpts.push(cmpFunc);
      cmpFunc = Function.apply(null, cmpOpts);
    } catch(e) {
      // TODO: add flag to reportError to know if it's at compile time or runtime
      helpers.reportError(e, 0, 0, originalFunc, /\n/, false);
    }
  }

  // need this to enable decompilation / relinking
  cmpFunc.options = {
     simple: options.simple
    ,modelName: options.modelName
    ,helpersName: options.helpersName
  }

  var linked;

  if( options.asHelper ){

    cmpFunc.options.args = options.args;
    cmpFunc.options.asHelper = options.asHelper;

    linked = function(){
      return cmpFunc.apply(this, slice.call(arguments));
    }

    helpers[options.asHelper] = linked;

  } else {

    linked = function( model, opts ){
      if( options.simple ){
        var ctx = {
           buffer: []
          ,escape: Helpers.prototype.escape
          ,raw: Helpers.prototype.raw
        }
        return cmpFunc( model, ctx, opts, runtime );
      }

      opts = divineRuntimeTplOptions( model, opts );
      return cmpFunc( model, (opts &amp;&amp; opts.context) || new Helpers( model ), opts, runtime );
    }
  }

  // show the template-specific code, instead of the generic linked function
  linked['toString'] = function(){ return cmpFunc.toString(); }

  // shortcut to show the actual linked function
  linked['_toString'] = function(){ return Function.prototype.toString.call(linked) }

  // This assumes a vash global, and should be deprecated.
  // TODO: @deprecate
  linked['toClientString'] = function(){
    return 'vash.link( '
      + cmpFunc.toString() + ', '
      + JSON.stringify( cmpFunc.options ) + ' )';
  }

  return linked;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		return (__vopts &amp;&amp; __vopts.asContext)
			? html
			: html.toString();
	}

If `toClientString` is called on that function, the following is returned:

	vash.<span class="apidocCodeKeywordSpan">link</span>( function anonymous(model,html,__vopts,vash) {
		var __vbuffer = html.buffer;
		html.options = __vopts;
		model = model || {};
		__vbuffer.push('&lt;p&gt;&lt;/p&gt;\n');
		(__vopts &amp;&amp; __vopts.onRenderEnd &amp;&amp; __vopts.onRenderEnd(null, html));
		return (__vopts &amp;&amp; __vopts.asContext)
			? html
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.loadFile" id="apidoc.element.vash.loadFile">
        function <span class="apidocSignatureSpan">vash.</span>loadFile
        <span class="apidocSignatureSpan">(filepath, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadFile = function (filepath, options, cb){

  // options are passed in via Express
  // {
  //   settings:
  //   {
  //      env: 'development',
  //    'jsonp callback name': 'callback',
  //    'json spaces': 2,
  //    views: '/Users/drew/Dropbox/js/vash/test/fixtures/views',
  //    'view engine': 'vash'
  //   },
  //   _locals: [Function: locals],
  //   cache: false
  // }

  // The only required options are:
  //
  // settings: {
  //     views: ''
  // }

  options = copyrtl({}, vash.config, options || {});

  var browser = helpers.config.browser
    ,tpl

  if( !browser &amp;&amp; options.settings &amp;&amp; options.settings.views ){
    // this will really only have an effect on windows
    filepath = path.normalize( filepath );

    if( filepath.indexOf( path.normalize( options.settings.views ) ) === -1 ){
      // not an absolute path
      filepath = path.join( options.settings.views, filepath );
    }

    if( !path.extname( filepath ) ){
      filepath += '.' + ( options.settings['view engine'] || 'vash' )
    }
  }

  // TODO: auto insert 'model' into arguments
  try {
    // if browser, tpl must exist in tpl cache
    tpl = options.cache || browser
      ? helpers.tplcache[filepath] || ( helpers.tplcache[filepath] = vash.compile(fs.readFileSync(filepath, 'utf8')) )
      : vash.compile( fs.readFileSync(filepath, 'utf8') )

    cb &amp;&amp; cb(null, tpl);
  } catch(e) {
    cb &amp;&amp; cb(e, null);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.lookup" id="apidoc.element.vash.lookup">
        function <span class="apidocSignatureSpan">vash.</span>lookup
        <span class="apidocSignatureSpan">( path, model )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function ( path, model ){
  var tpl = runtime.helpers.tplcache[path];
  if( !tpl ){ throw new Error('Could not find template: ' + path); }
  if( model ){ return tpl(model); }
  else return tpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This is primarily an internal function, and has relatively complex behavioral differences depending on what options are passed in
. It takes either a decompiled string function or function instance and "links" it by wrapping it in a closure that provides
 access to Vash's runtime functions. It also sets up things like `toClientString` and `toString`. It makes precompiled functions
 possible. As a developer working on Vash, it's best to take a look at the [source itself][].

[source itself]: https://github.com/kirbysayshi/vash/blob/master/src/vruntime.js

&lt;a name="vash-lookup"&gt;&lt;/a&gt;vash.lookup
-------------------

	vash.<span class="apidocCodeKeywordSpan">lookup</span>(str_path) -&gt; Function

Attempts to grab a template from `vash.helpers.tplcache[str_path]`, and throws an exception if it is not found.

	vash.lookup(str_path, model) -&gt; Function

If `model` is passed and the template is found, the template is automatically executed and returned using `model` as the model.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser" id="apidoc.element.vash.parser">
        function <span class="apidocSignatureSpan">vash.</span>parser
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(opts) {
  this.lg = debug('vash:parser');
  this.tokens = [];
  this.deferredTokens = [];
  this.node = null;
  this.stack = [];
  this.inputText = '';
  this.opts = opts || {};
  this.previousNonWhitespace = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.renderFile" id="apidoc.element.vash.renderFile">
        function <span class="apidocSignatureSpan">vash.</span>renderFile
        <span class="apidocSignatureSpan">(filepath, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderFile = function (filepath, options, cb){

  vash.loadFile(filepath, options, function(err, tpl){
    // auto setup an `onRenderEnd` callback to seal the layout
    var prevORE = options.onRenderEnd;

    cb( err, !err &amp;&amp; tpl(options, function(err, ctx){
      ctx.finishLayout()
      if( prevORE ) prevORE(err, ctx);
    }) );
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.uninstall" id="apidoc.element.vash.uninstall">
        function <span class="apidocSignatureSpan">vash.</span>uninstall
        <span class="apidocSignatureSpan">( path )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function ( path ){
  var  cache = runtime.helpers.tplcache
    ,deleted = false;

  if( typeof path === 'string' ){
    return delete cache[path];
  } else {
    Object.keys(cache).forEach(function(key){
      if( cache[key] === path ){ deleted = delete cache[key]; }
    })
    return deleted;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	vash.install(obj) -&gt; obj

If an object containing string keys pointing at template functions is passed, then the object's keys are used as the keys for
 `vash.helpers.tplcache`. This is especially useful when using [vash.compileBatch][], as the result can be directly passed.

&lt;a name="vash-uninstall"&gt;&lt;/a&gt;vash.uninstall
----------------------

	vash.<span class="apidocCodeKeywordSpan">uninstall</span>(str_path) -&gt; bool

Deletes the key named `str_path` from `vash.helpers.tplcache`.

	vash.uninstall(func_tpl) -&gt; bool

Loops through all templates in `vash.helpers.tplcache`, and if a strict equality is successful, deletes that reference.
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.Mark" id="apidoc.module.vash.Mark">module vash.Mark</a></h1>


    <h2>
        <a href="#apidoc.element.vash.Mark.Mark" id="apidoc.element.vash.Mark.Mark">
        function <span class="apidocSignatureSpan">vash.</span>Mark
        <span class="apidocSignatureSpan">( buffer, debugName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Mark = function ( buffer, debugName ){
  this.uid = '[VASHMARK-'
    + ~~( Math.random() * 10000000 )
    + (debugName ? ':' + debugName : '')
    + ']';
  this.markedIndex = 0;
  this.buffer = buffer;
  this.destroyed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.Mark.uidLike" id="apidoc.element.vash.Mark.uidLike">
        function <span class="apidocSignatureSpan">vash.Mark.</span>uidLike
        <span class="apidocSignatureSpan">( str )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uidLike = function ( str ){
  return (str || '').search( reMark ) &gt; -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.Mark.prototype" id="apidoc.module.vash.Mark.prototype">module vash.Mark.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.vash.Mark.prototype.destroy" id="apidoc.element.vash.Mark.prototype.destroy">
        function <span class="apidocSignatureSpan">vash.Mark.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (){

  var found = this.findInBuffer();

  if( found &gt; -1 ){
    this.buffer.splice( found, 1 );
    this.markedIndex = -1;
  }

  this.destroyed = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Buffer.prototype.fromMark = function( mark ) {
  var found = mark.findInBuffer();

  if( found &gt; -1 ){
    // automatically destroy the mark from the buffer
    mark.<span class="apidocCodeKeywordSpan">destroy</span>();
    // `found` will still be valid for a manual splice
    return this._vo.splice( found, this._vo.length );
  }

  return [];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.Mark.prototype.findInBuffer" id="apidoc.element.vash.Mark.prototype.findInBuffer">
        function <span class="apidocSignatureSpan">vash.Mark.prototype.</span>findInBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findInBuffer = function (){

  if( this.destroyed ){
    return -1;
  }

  if( this.markedIndex &amp;&amp; this.buffer.index( this.markedIndex ) === this.uid ){
    return this.markedIndex;
  }

  // The mark may be within a string due to block manipulation shenanigans.
  var escaped = this.uid.replace(/(\[|\])/g, '\\$1');
  var re = new RegExp(escaped);
  return this.markedIndex = this.buffer.indexOf( re );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var mark = new Mark( this, debugName );
mark.markedIndex = this._vo.length;
this._vo.push( mark.uid );
return mark;
};

Buffer.prototype.fromMark = function( mark ) {
var found = mark.<span class="apidocCodeKeywordSpan">findInBuffer</span>();

if( found &gt; -1 ){
  // automatically destroy the mark from the buffer
  mark.destroy();
  // `found` will still be valid for a manual splice
  return this._vo.splice( found, this._vo.length );
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.error" id="apidoc.module.vash.error">module vash.error</a></h1>


    <h2>
        <a href="#apidoc.element.vash.error.context" id="apidoc.element.vash.error.context">
        function <span class="apidocSignatureSpan">vash.error.</span>context
        <span class="apidocSignatureSpan">(input, lineno, columnno, linebreak)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">context = function (input, lineno, columnno, linebreak) {
  linebreak = linebreak || '!LB!';

  var lines = input.split(linebreak)
    , contextSize = lineno === 0 &amp;&amp; columnno === 0 ? lines.length - 1 : 3
    , start = Math.max(0, lineno - contextSize)
    , end = Math.min(lines.length, lineno + contextSize);

  return lines
    .slice(start, end)
    .map(function(line, i, all){
      var curr = i + start + 1;

      return (curr === lineno ? '  &gt; ' : '    ')
        + (curr &lt; 10 ? ' ' : '')
        + curr
        + ' | '
        + line;
    }).join('\n');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Parser.prototype.decorateError = function(err, line, column) {
err.message = ''
  + err.message
  + ' at template line ' + line
  + ', column ' + column + '\n\n'
  + 'Context: \n'
  + error.<span class="apidocCodeKeywordSpan">context</span>(this.inputText, line, column, '\n')
  + '\n';

return err;
}

Parser.prototype.write = function(tokens) {
if (!Array.isArray(tokens)) tokens = [tokens];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.helpers" id="apidoc.module.vash.helpers">module vash.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.vash.helpers._ensureLayoutProps" id="apidoc.element.vash.helpers._ensureLayoutProps">
        function <span class="apidocSignatureSpan">vash.helpers.</span>_ensureLayoutProps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_ensureLayoutProps = function (){
  this.appends = this.appends || {};
  this.prepends = this.prepends || {};
  this.blocks = this.blocks || {};

  this.blockMarks = this.blockMarks || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers._handlePrependAppend" id="apidoc.element.vash.helpers._handlePrependAppend">
        function <span class="apidocSignatureSpan">vash.helpers.</span>_handlePrependAppend
        <span class="apidocSignatureSpan">( type, name, ctn )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handlePrependAppend = function ( type, name, ctn ){
  this._ensureLayoutProps();

  var start = this.buffer.mark()
    ,content
    ,stack = this[type]
    ,namedStack = stack[name] || ( stack[name] = [] )

  ctn( this.model );
  content = this.buffer.fromMark( start );

  namedStack.push( content );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.append" id="apidoc.element.vash.helpers.append">
        function <span class="apidocSignatureSpan">vash.helpers.</span>append
        <span class="apidocSignatureSpan">(name, ctn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (name, ctn){
  this._handlePrependAppend( 'appends', name, ctn );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if
it is referenced in the content. This may change in a future version of Vash._


&lt;a name="vash-helpers-append"&gt;&lt;/a&gt;vash.helpers.append
---------------------------

	vash.helpers.<span class="apidocCodeKeywordSpan">append</span>(name, cb)

[vash.helpers.append][] is a way to control the content of a block from within an extending template. In this way, it allows templates
 to invert control over content "above" them.

An example is a navigation area. Perhaps there is a default navigation list that templates can add to:

	// layout.vash
	&lt;ul&gt;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.block" id="apidoc.element.vash.helpers.block">
        function <span class="apidocSignatureSpan">vash.helpers.</span>block
        <span class="apidocSignatureSpan">(name, ctn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function (name, ctn){
  this._ensureLayoutProps();

  var  self = this
    // ensure that we have a list of marks for this name
    ,marks = this.blockMarks[name] || ( this.blockMarks[name] = [] )
    // ensure a list of blocks for this name
    ,blocks = this.blocks[name] || ( this.blocks[name] = [] )
    ,start
    ,content;

  // render out the content immediately, if defined, to attempt to grab
  // "dependencies" like other includes, blocks, etc
  if( ctn ){
    start = this.buffer.mark();
    ctn( this.model );
    content = this.buffer.fromMark( start );

    // add rendered content to named list of blocks
    if( content.length &amp;&amp; !this.isExtending ){
      blocks.push( content );
    }

    // if extending the rendered content must be allowed to be redefined
    if( content.length &amp;&amp; this.isExtending ){
      blocks.unshift( content );
    }
  }

  // mark the current location as "where this block will end up"
  marks.push( this.buffer.mark( 'block-' + name ) );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This is Vash's main form of inheritance for view templates. `parent_path` is the location or name of the template to be extended
.

A template can define various locations in itself that can be [overridden](#vash-helpers-block) or [added to](#vash-helpers-append
). In addition, a template that calls `extend` can even be extended itself!

In the following example, this template extends another named [layout.vash][]. [Layout.vash][] defines an empty [block](#vash-helpers
-block) named 'content', which is overrided in this example.

	@html.extend('layout', function(model){
		@html.<span class="apidocCodeKeywordSpan">block</span>('content', function(model){
			&lt;h1 class="name"&gt;Welcome to &lt;/h1&gt;
		})
	})

_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if
it is referenced in the content. This may change in a future version of Vash._
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.constructor" id="apidoc.element.vash.helpers.constructor">
        function <span class="apidocSignatureSpan">vash.helpers.</span>constructor
        <span class="apidocSignatureSpan">( model )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Helpers( model ) {
  this.buffer = new Buffer();
  this.model  = model;
  this.options = null; // added at render time

  this.vl = 0;
  this.vc = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.escape" id="apidoc.element.vash.helpers.escape">
        function <span class="apidocSignatureSpan">vash.helpers.</span>escape
        <span class="apidocSignatureSpan">( val )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escape = function ( val ) {
  var func = function() { return val; };

  val = val != null ? val : "";

  if ( typeof val.toHtmlString !== "function" ) {

    val = val.toString().replace( HTML_REGEX, HTML_REPLACER );

    return {
       toHtmlString: func
      ,toString: func
    };
  }

  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    + opts.helpersName + '.vl = ' + node.endloc.line + ', '
    + opts.helpersName + '.vc = ' + node.endloc.column + '; \n'
  : '';
}

function maybeHTMLEscape(node, opts, str) {
if (parentIsContent(node) &amp;&amp; opts.htmlEscape) {
  return opts.helpersName + '.<span class="apidocCodeKeywordSpan">escape</span>(' + str + ').toHtmlString()';
} else {
  return str;
}
}

function replaceDevTokens(str, opts){
return str
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.extend" id="apidoc.element.vash.helpers.extend">
        function <span class="apidocSignatureSpan">vash.helpers.</span>extend
        <span class="apidocSignatureSpan">(path, ctn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (path, ctn){
  var  self = this
    ,buffer = this.buffer
    ,origModel = this.model
    ,layoutCtx;

  this._ensureLayoutProps();

  // this is a synchronous callback
  vash.loadFile(path, this.model, function(err, tpl){

    if (err) throw err;

    // any content that is outside of a block but within an "extend"
    // callback is completely thrown away, as the destination for such
    // content is undefined
    var start = self.buffer.mark();

    ctn(self.model);

    // ... and just throw it away
    var  content = self.buffer.fromMark( start )
      // TODO: unless it's a mark id? Removing everything means a block
      // MUST NOT be defined in an extend callback
      //,filtered = content.filter( vash.Mark.uidLike )

    //self.buffer.push( filtered );

    // `isExtending` is necessary because named blocks in the layout
    // will be interpreted after named blocks in the content. Since
    // layout named blocks should only be used as placeholders in the
    // event that their content is redefined, `block` must know to add
    // the defined content at the head or tail or the block stack.
    self.isExtending = true;
    tpl( self.model, { context: self } );
    self.isExtending = false;
  });

  this.model = origModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
[Layout.vash]: https://github.com/kirbysayshi/vash-express-example/blob/master/views/layout.vash



&lt;a name="vash-helpers-extend"&gt;&lt;/a&gt;vash.helpers.extend
---------------------------

	vash.helpers.<span class="apidocCodeKeywordSpan">extend</span>(parent_path, cb)

This is Vash's main form of inheritance for view templates. `parent_path` is the location or name of the template to be extended
.

A template can define various locations in itself that can be [overridden](#vash-helpers-block) or [added to](#vash-helpers-append
). In addition, a template that calls `extend` can even be extended itself!

In the following example, this template extends another named [layout.vash][]. [Layout.vash][] defines an empty [block](#vash-helpers
-block) named 'content', which is overrided in this example.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.finishLayout" id="apidoc.element.vash.helpers.finishLayout">
        function <span class="apidocSignatureSpan">vash.helpers.</span>finishLayout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishLayout = function (){
  this._ensureLayoutProps();

  var self = this, name, marks, blocks, prepends, appends, injectMark, m, content, block

  // each time `.block` is called, a mark is added to the buffer and
  // the `blockMarks` stack. Find the newest/"highest" mark on the stack
  // for each named block, and insert the rendered content (prepends, block, appends)
  // in place of that mark

  for( name in this.blockMarks ){

    marks = this.blockMarks[name];

    prepends = this.prepends[name];
    blocks = this.blocks[name];
    appends = this.appends[name];

    injectMark = marks.pop();

    // mark current point in buffer in prep to grab rendered content
    m = this.buffer.mark();

    prepends &amp;&amp; prepends.forEach(function(p){ self.buffer.pushConcat( p ); });

    // a block might never have a callback defined, e.g. is optional
    // with no default content
    block = blocks.pop();
    block &amp;&amp; this.buffer.pushConcat( block );

    appends &amp;&amp; appends.forEach(function(a){ self.buffer.pushConcat( a ); });

    // grab rendered content
    content = this.buffer.fromMark( m )

    // Join, but split out the VASHMARKS so further buffer operations are still
    // sane. Join is required to prevent max argument errors when large templates
    // are being used.
    content = compactContent(content);

    // Prep for apply, ensure the right location (mark) is used for injection.
    content.unshift( injectMark, 0 );
    this.buffer.spliceMark.apply( this.buffer, content );
  }

  for( name in this.blockMarks ){

    // kill all other marks registered as blocks
    this.blockMarks[name].forEach(function(m){ m.destroy(); });
  }

  // this should only be able to happen once
  delete this.blockMarks;
  delete this.prepends;
  delete this.blocks;
  delete this.appends;

  // and return the whole thing
  return this.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.highlight" id="apidoc.element.vash.helpers.highlight">
        function <span class="apidocSignatureSpan">vash.helpers.</span>highlight
        <span class="apidocSignatureSpan">(lang, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">highlight = function (lang, cb){

  // context (this) is and instance of Helpers, aka a rendering context

  // mark() returns an internal `Mark` object
  // Use it to easily capture output...
  var startMark = this.buffer.mark();

  // cb() is simply a user-defined function. It could (and should) contain
  // buffer additions, so we call it...
  cb( this.model );

  // ... and then use fromMark() to grab the output added by cb().
  var cbOutLines = this.buffer.fromMark(startMark);

  // The internal buffer should now be back to where it was before this
  // helper started, and the output is completely contained within cbOutLines.

  this.buffer.push( '&lt;pre&gt;&lt;code&gt;' );

  if( helpers.config.highlighter ){
    this.buffer.push( helpers.config.highlighter(lang, cbOutLines.join('')).value );
  } else {
    this.buffer.push( cbOutLines );
  }

  this.buffer.push( '&lt;/code&gt;&lt;/pre&gt;' );

  // returning is allowed, but could cause surprising effects. A return
  // value will be directly added to the output directly following the above.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.include" id="apidoc.element.vash.helpers.include">
        function <span class="apidocSignatureSpan">vash.helpers.</span>include
        <span class="apidocSignatureSpan">(name, model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">include = function (name, model){

  var  self = this
    ,buffer = this.buffer
    ,origModel = this.model;

  // TODO: should this be in a new context? Jade looks like an include
  // is not shared with parent context

  // this is a synchronous callback
  vash.loadFile(name, this.model, function(err, tpl){
    if (err) throw err;
    tpl( model || self.model, { context: self } );
  });

  this.model = origModel;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if
it is referenced in the content. This may change in a future version of Vash._


&lt;a name="vash-helpers-include"&gt;&lt;/a&gt;vash.helpers.include
----------------------------

	vash.helpers.<span class="apidocCodeKeywordSpan">include</span>(name, model)

This grabs the template `name` and executes it using `model` as the... model. [vash.helpers.include][] is used to literally include
 the contents of another template. It is analogous to a "partial" in other view engines. Except that there is a hidden
 power here... as included templates share the same "view engine scope" as other templates, and can thus call all of the
 layout helper functions, and it will _just work_. Thus, a block within an included template can append to a block defined in a
parent. It can even use [vash.helpers.extend][]!

&lt;a name="compiled-helpers"&gt;&lt;/a&gt;Compiled Helpers
========================

A relatively new feature in Vash (added in 0.6), compiled helpers are a bit meta. They allow a developer to write a helper using
 Vash syntax instead of the manual buffer API. The below buffer API example `imgfigure` could be rewritten:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.prepend" id="apidoc.element.vash.helpers.prepend">
        function <span class="apidocSignatureSpan">vash.helpers.</span>prepend
        <span class="apidocSignatureSpan">(name, ctn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (name, ctn){
  this._handlePrependAppend( 'prepends', name, ctn );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if
it is referenced in the content. This may change in a future version of Vash._


&lt;a name="vash-helpers-prepend"&gt;&lt;/a&gt;vash.helpers.prepend
----------------------------

	vash.helpers.<span class="apidocCodeKeywordSpan">prepend</span>(name, cb)

[vash.helpers.prepend][] behaves nearly the same as [vash.helpers.append][] except that it places content at the beginning of a
block instead of at the end. The previous example, if `prepend` were substituted for `append`, would render as:

	&lt;li&gt;&lt;a href="/another"&gt;Another Link&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;&lt;a href="/"&gt;Home&lt;/a&gt;&lt;/li&gt;

_Tech note: due to the way JS scoping works, the `model` parameter of the `cb` function must be explicitely defined as above if
it is referenced in the content. This may change in a future version of Vash._
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.raw" id="apidoc.element.vash.helpers.raw">
        function <span class="apidocSignatureSpan">vash.helpers.</span>raw
        <span class="apidocSignatureSpan">( val )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">raw = function ( val ) {
  var func = function() { return val; };

  val = val != null ? val : "";

  return {
     toHtmlString: func
    ,toString: func
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	&lt;p&gt;&amp;lt;img /&amp;gt;&lt;/p&gt;

If you are sure that you trust the content and/or need to display HTML-like values, you can escape the HTML escaping via a call
to Vash's [helper system][]: `html.raw`.

input:

	// model = { what: '&lt;img /&gt;' }
	&lt;p&gt;@html.<span class="apidocCodeKeywordSpan">raw</span>(model.what)&lt;/p&gt;

output:

	&lt;p&gt;&lt;img /&gt;&lt;/p&gt;

This behavior can be disabled using [vash.config.htmlEscape][].
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.reportError" id="apidoc.element.vash.helpers.reportError">
        function <span class="apidocSignatureSpan">vash.helpers.</span>reportError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportError = function () {
  this.constructor.reportError.apply( this, arguments );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			html.vl = 1, html.vc = 7;
			__vbuffer.push('\n');
			(__vopts &amp;&amp; __vopts.onRenderEnd &amp;&amp; __vopts.onRenderEnd(null, html));
			return (__vopts &amp;&amp; __vopts.asContext)
				? html
				: html.toString();
		} catch( e ){
			html.<span class="apidocCodeKeywordSpan">reportError</span>( e, html.vl, html.vc, "&lt;p&gt;&lt;/p&gt;!LB!" );
		}
	}

And that same template with `debug` set to `false`:

	function anonymous(model,html,__vopts,vash) {
		var __vbuffer = html.buffer;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.toHtmlString" id="apidoc.element.vash.helpers.toHtmlString">
        function <span class="apidocSignatureSpan">vash.helpers.</span>toHtmlString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHtmlString = function (){
  // not calling buffer.toString() results in 2x speedup
  return this.buffer._vo.join('');//.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    + opts.helpersName + '.vl = ' + node.endloc.line + ', '
    + opts.helpersName + '.vc = ' + node.endloc.column + '; \n'
  : '';
}

function maybeHTMLEscape(node, opts, str) {
if (parentIsContent(node) &amp;&amp; opts.htmlEscape) {
  return opts.helpersName + '.escape(' + str + ').<span class="apidocCodeKeywordSpan">toHtmlString</span>()';
} else {
  return str;
}
}

function replaceDevTokens(str, opts){
return str
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.toString" id="apidoc.element.vash.helpers.toString">
        function <span class="apidocSignatureSpan">vash.helpers.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (){
  // not calling buffer.toString() results in 2x speedup
  return this.buffer._vo.join('');//.toString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			html.vl = 1, html.vc = 3;
			__vbuffer.push('&lt;/p&gt;');
			html.vl = 1, html.vc = 7;
			__vbuffer.push('\n');
			(__vopts &amp;&amp; __vopts.onRenderEnd &amp;&amp; __vopts.onRenderEnd(null, html));
			return (__vopts &amp;&amp; __vopts.asContext)
				? html
				: html.<span class="apidocCodeKeywordSpan">toString</span>();
		} catch( e ){
			html.reportError( e, html.vl, html.vc, "&lt;p&gt;&lt;/p&gt;!LB!" );
		}
	}

And that same template with `debug` set to `false`:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.trim" id="apidoc.element.vash.helpers.trim">
        function <span class="apidocSignatureSpan">vash.helpers.</span>trim
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trim = function (val){
  return val.replace(/^\s*|\s*$/g, '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.helpers.constructor" id="apidoc.module.vash.helpers.constructor">module vash.helpers.constructor</a></h1>


    <h2>
        <a href="#apidoc.element.vash.helpers.constructor.constructor" id="apidoc.element.vash.helpers.constructor.constructor">
        function <span class="apidocSignatureSpan">vash.helpers.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Function() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.helpers.constructor.reportError" id="apidoc.element.vash.helpers.constructor.reportError">
        function <span class="apidocSignatureSpan">vash.helpers.constructor.</span>reportError
        <span class="apidocSignatureSpan">(e, lineno, chr, orig, lb, atRenderTime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportError = function (e, lineno, chr, orig, lb, atRenderTime){

  lb = lb || '!LB!';

  var contextStr = error.context(orig, lineno, chr, lb);

  e.vashlineno = lineno;
  e.vashcharno = chr;
  e.message = 'Problem while '
    + (atRenderTime ? 'rendering' : 'compiling')
    + ' template at line '
    + lineno + ', character ' + chr
    + '.\nOriginal message: ' + e.message + '.'
    + '\nContext: \n\n' + contextStr + '\n\n';

  throw e;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			html.vl = 1, html.vc = 7;
			__vbuffer.push('\n');
			(__vopts &amp;&amp; __vopts.onRenderEnd &amp;&amp; __vopts.onRenderEnd(null, html));
			return (__vopts &amp;&amp; __vopts.asContext)
				? html
				: html.toString();
		} catch( e ){
			html.<span class="apidocCodeKeywordSpan">reportError</span>( e, html.vl, html.vc, "&lt;p&gt;&lt;/p&gt;!LB!" );
		}
	}

And that same template with `debug` set to `false`:

	function anonymous(model,html,__vopts,vash) {
		var __vbuffer = html.buffer;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.lexer" id="apidoc.module.vash.lexer">module vash.lexer</a></h1>


    <h2>
        <a href="#apidoc.element.vash.lexer.lexer" id="apidoc.element.vash.lexer.lexer">
        function <span class="apidocSignatureSpan">vash.</span>lexer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VLexer(){
  this.lg = debug('vash:lexer');
  this.input = '';
  this.originalInput = '';
  this.lineno = 1;
  this.charno = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.lexer.prototype" id="apidoc.module.vash.lexer.prototype">module vash.lexer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.vash.lexer.prototype.advance" id="apidoc.element.vash.lexer.prototype.advance">
        function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>advance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">advance = function () {

  var i, name, test, result;

  for(i = 0; i &lt; tokens.tests.length; i += 2){
    test = tokens.tests[i+1];
    test.displayName = tokens.tests[i];

    if(typeof test === 'function'){
      // assume complex callback
      result = test.call(this);
    }

    if(typeof test.exec === 'function'){
      // assume regex
      result = this.scan(test, tokens.tests[i]);
    }

    if( result ){
      return result;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return true;
},

read: function() {
  var out = []
    , result;
  while(this.input.length) {
    result = this.<span class="apidocCodeKeywordSpan">advance</span>();
    if (result) {
      out.push(result);
      this.lg('Read %s at line %d, column %d with content %s',
        result.type, result.line, result.chr, result.val.replace(/(\n)/, '\\n'));
    }
  }
  return out;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.lexer.prototype.read" id="apidoc.element.vash.lexer.prototype.read">
        function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {
  var out = []
    , result;
  while(this.input.length) {
    result = this.advance();
    if (result) {
      out.push(result);
      this.lg('Read %s at line %d, column %d with content %s',
        result.type, result.line, result.chr, result.val.replace(/(\n)/, '\\n'));
    }
  }
  return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var opts = copyrtl({}, exports.config, options || {});

var l = new Lexer();

l.write(markup);
var tokens = l.<span class="apidocCodeKeywordSpan">read</span>();

var p = new Parser(opts);
p.write(tokens);
var more = true;
while(more !== null) more = p.read();

p.checkStack();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.lexer.prototype.scan" id="apidoc.element.vash.lexer.prototype.scan">
        function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>scan
        <span class="apidocSignatureSpan">(regexp, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scan = function (regexp, type){
  var captures, token;
  if (captures = regexp.exec(this.input)) {
    this.input = this.input.substr((captures[1].length));

    token = {
      type: type
      ,line: this.lineno
      ,chr: this.charno
      ,val: captures[1] || ''
      ,toString: function(){
        return '[' + this.type
          + ' (' + this.line + ',' + this.chr + '): '
          + this.val.replace(/(\n)/, '\\n') + ']';
      }
    };

    this.charno += captures[0].length;
    return token;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(typeof test === 'function'){
      // assume complex callback
      result = test.call(this);
    }

    if(typeof test.exec === 'function'){
      // assume regex
      result = this.<span class="apidocCodeKeywordSpan">scan</span>(test, tokens.tests[i]);
    }

    if( result ){
      return result;
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.lexer.prototype.write" id="apidoc.element.vash.lexer.prototype.write">
        function <span class="apidocSignatureSpan">vash.lexer.prototype.</span>write
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (input) {
  var normalized = input.replace(/\r\n|\r/g, '\n');

  // Kill BOM if this is the first chunk.
  if (this.originalInput.length == 0) {
    normalized = normalized.replace(/^\uFEFF/, '');
  }

  this.input += normalized;
  this.originalInput += normalized;
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error('Empty or non-string cannot be compiled');
}

var opts = copyrtl({}, exports.config, options || {});

var l = new Lexer();

l.<span class="apidocCodeKeywordSpan">write</span>(markup);
var tokens = l.read();

var p = new Parser(opts);
p.write(tokens);
var more = true;
while(more !== null) more = p.read();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.nodestuff" id="apidoc.module.vash.nodestuff">module vash.nodestuff</a></h1>


    <h2>
        <a href="#apidoc.element.vash.nodestuff.clean" id="apidoc.element.vash.nodestuff.clean">
        function <span class="apidocSignatureSpan">vash.nodestuff.</span>clean
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clean(node) {
  return Object.keys(node).reduce(function(out, key) {
    var value = node[key];
    if (key[0] !== '_' &amp;&amp; typeof value !== 'function') {
      if (Array.isArray(value)) {
        out[key] = value.map(clean);
      } else {
        out[key] = value;
      }
    }
    return out;
  }, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.parser" id="apidoc.module.vash.parser">module vash.parser</a></h1>


    <h2>
        <a href="#apidoc.element.vash.parser.parser" id="apidoc.element.vash.parser.parser">
        function <span class="apidocSignatureSpan">vash.</span>parser
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(opts) {
  this.lg = debug('vash:parser');
  this.tokens = [];
  this.deferredTokens = [];
  this.node = null;
  this.stack = [];
  this.inputText = '';
  this.opts = opts || {};
  this.previousNonWhitespace = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.parser.prototype" id="apidoc.module.vash.parser.prototype">module vash.parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.vash.parser.prototype.checkStack" id="apidoc.element.vash.parser.prototype.checkStack">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>checkStack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkStack = function () {
  // Throw if something is unclosed that should be.
  var i = this.stack.length-1;
  var node;
  var msg;
  // A full AST is always:
  // Program, Markup, MarkupContent, ...
  while(i &gt;= 2) {
    node = this.stack[i];
    if (node.endOk &amp;&amp; !node.endOk()) {
      // Attempt to make the error readable
      delete node.values;
      msg = 'Found unclosed ' + node.type;
      var err = new Error(msg);
      err.name = 'UnclosedNodeError';
      throw this.decorateError(
        err,
        node.startloc.line,
        node.startloc.column);
    }
    i--;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tokens = l.read();

var p = new Parser(opts);
p.write(tokens);
var more = true;
while(more !== null) more = p.read();

p.<span class="apidocCodeKeywordSpan">checkStack</span>();

// Stash the original input (new lines normalized by the lexer).
opts.source = l.originalInput;

p.lg(p.dumpAST());

var compiled = codegen(p.stack[0], opts);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.closeNode" id="apidoc.element.vash.parser.prototype.closeNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>closeNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeNode = function (node) {
  var toClose = this.stack[this.stack.length-1];
  if (node !== toClose) {
    var msg = 'InvalidCloseAction: '
      + 'Expected ' + node.type + ' in stack, instead found '
      + toClose.type;
    throw new Error(msg);
  }

  this.stack.pop();
  var last = this.stack[this.stack.length-1];

  this.lg('Closing node %s (%s), returning to node %s',
    node.type, node.name, last.type)

  this.node = last;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  updateLoc(node, curr);
  return true;
}

if (curr.type === node._waitingForClose) {
  this.flag(node, '_waitingForClose', null)
  updateLoc(node, curr);
  this.<span class="apidocCodeKeywordSpan">closeNode</span>(node);
  return true;
}

if (curr.type === tks.DOUBLE_FORWARD_SLASH &amp;&amp; !node._waitingForClose){
  this.flag(node, '_waitingForClose', tks.NEWLINE);
  updateLoc(node, curr);
  return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueBlockNode" id="apidoc.element.vash.parser.prototype.continueBlockNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueBlockNode
        <span class="apidocSignatureSpan">(node, curr, next, ahead, nnwon)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueBlockNode = function (node, curr, next, ahead, nnwon) {

  var valueNode = node.values[node.values.length-1];

  if (curr.type === tks.AT_STAR_OPEN) {
    this.openNode(new CommentNode(), node.body);
    return false;
  }

  if (curr.type === tks.DOUBLE_FORWARD_SLASH &amp;&amp; !node._waitingForEndQuote) {
    this.openNode(new CommentNode(), node.body);
    return false;
  }

  if (
    curr.type === tks.AT_COLON
    &amp;&amp; (!node.hasBraces || node._reachedOpenBrace)
  ) {
    valueNode = this.openNode(new MarkupContentNode(), node.values);
    return false;
  }

  if (
    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)
    &amp;&amp; !node._reachedOpenBrace
    &amp;&amp; !node.keyword
  ) {
    this.flag(node, 'keyword', curr.val);
    return true;
  }

  if (
    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)
    &amp;&amp; !node._reachedOpenBrace
  ) {
    // Assume something like if (test) expressionstatement;
    this.flag(node, 'hasBraces', false);
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (
    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)
    &amp;&amp; !node._reachedCloseBrace
    &amp;&amp; node.hasBraces
    &amp;&amp; !node._waitingForEndQuote
  ) {
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (
    (curr.type === tks.BLOCK_KEYWORD || curr.type === tks.FUNCTION)
    &amp;&amp; node._reachedCloseBrace
    &amp;&amp; !node._waitingForEndQuote
  ) {
    valueNode = this.openNode(new BlockNode(), node.tail);
    updateLoc(valueNode, curr);
    return false;
  }

  if (
    curr.type === tks.BRACE_OPEN
    &amp;&amp; !node._reachedOpenBrace
    &amp;&amp; !node._waitingForEndQuote
  ) {
    this.flag(node, '_reachedOpenBrace', true);
    this.flag(node, 'hasBraces', true);
    if (this.opts.favorText) {
      valueNode = this.openNode(new MarkupContentNode(), node.values);
      updateLoc(valueNode, curr);
    }
    return true;
  }

  if (
    curr.type === tks.BRACE_OPEN
    &amp;&amp; !node._waitingForEndQuote
  ) {
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (
    curr.type === tks.BRACE_CLOSE
    &amp;&amp; node.hasBraces
    &amp;&amp; !node._reachedCloseBrace
    &amp;&amp; !node._waitingForEndQuote
  ) {
    updateLoc(node, curr);
    this.flag(node, '_reachedCloseBrace', true);

    // Try to leave whitespace where it belongs, and allow `else {` to
    // be continued as the tail of this block.
    if (
      nnwon
      &amp;&amp; nnwon.type !== tks.BLOCK_KEYWORD
    ) {
      this.closeNode(node);
    }

    return true;
  }

  if (
    curr.type === tks.BRACE_CLOSE
    &amp;&amp; !node.hasBraces
  ) {
    // Probably something like:
    // @{ if() &lt;span&gt;&lt;/span&gt; }
    this.closeNode(node);
    updateLoc(node, curr);
    return false;
  }

  if (
    curr.type === tks.LT_SIGN
    &amp;&amp; (next.type === tks.AT || next.type === tks.IDENTIFIER)
    &amp;&amp; !node._waitingForEndQuote
    &amp;&amp; node._reachedCloseBrace
  ) {
    this.closeNode(node);
    updateLoc(node, curr);
    return false;
  }

  if (
    curr.type === tks.LT_SIGN
    &amp;&amp; (next.type === tks.AT || next.type === tks.IDENTIFIER)
    &amp;&amp; !node._waitingForEndQuote
    &amp;&amp; !node._reachedCloseBrace
  ) {
    valueNode = this.openNode(new MarkupNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (curr.type === tks.HTML_TAG_CLOSE) {
    if (
      (node.hasBraces &amp;&amp; node._reachedCloseBrace)
      || !node._reachedOpenBrace
    ) {
      updateLoc(node, curr);
      this.closeNode(node);
      return false;
    }

    // This is likely an invalid markup configuration, something like:
    // @if(bla) { &lt;img&gt;&lt;/img&gt; }
    // where &lt;img&gt; is an implicit void. Try to help the user in this
    // specific case.
    if (
      next
      &amp;&amp; next.type === tks.IDENTIFIER
      &amp;&amp; MarkupNode.isVoid(next.val)
    ){
      throw newUnexpectedClosingTagError(this, curr, curr.val + next.val);
    }
  }

  if (
    curr.type === tks.AT
    &amp;&amp; (next.type === tks.BLOCK_KEYWORD
      || next.type === tks.BRACE_OPEN
      | ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueCommentNode" id="apidoc.element.vash.parser.prototype.continueCommentNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueCommentNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueCommentNode = function (node, curr, next) {
  var valueNode = ensureTextNode(node.values);

  if (curr.type === tks.AT_STAR_OPEN &amp;&amp; !node._waitingForClose) {
    this.flag(node, '_waitingForClose', tks.AT_STAR_CLOSE)
    updateLoc(node, curr);
    return true;
  }

  if (curr.type === node._waitingForClose) {
    this.flag(node, '_waitingForClose', null)
    updateLoc(node, curr);
    this.closeNode(node);
    return true;
  }

  if (curr.type === tks.DOUBLE_FORWARD_SLASH &amp;&amp; !node._waitingForClose){
    this.flag(node, '_waitingForClose', tks.NEWLINE);
    updateLoc(node, curr);
    return true;
  }

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueExplicitExpressionNode" id="apidoc.element.vash.parser.prototype.continueExplicitExpressionNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueExplicitExpressionNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueExplicitExpressionNode = function (node, curr, next) {

  var valueNode = node.values[node.values.length-1];

  if (
    node.values.length === 0
    &amp;&amp; (curr.type === tks.AT || curr.type === tks.PAREN_OPEN)
  ) {
    // This is the beginning of the explicit (mark as consumed)
    this.flag(node, '_waitingForParenClose', true);
    updateLoc(node, curr);
    return true;
  }

  if (curr.type === tks.PAREN_OPEN &amp;&amp; !node._waitingForEndQuote) {
    // New explicit expression
    valueNode = this.openNode(new ExplicitExpressionNode(), node.values);
    updateLoc(valueNode, curr);
    // And do nothing with the token (mark as consumed)
    return true;
  }

  if (curr.type === tks.PAREN_CLOSE &amp;&amp; !node._waitingForEndQuote) {
    // Close current explicit expression
    this.flag(node, '_waitingForParenClose', false);
    updateLoc(node, curr);
    this.closeNode(node);
    // And do nothing with the token (mark as consumed)
    return true;
  }

  if (curr.type === tks.FUNCTION &amp;&amp; !node._waitingForEndQuote) {
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (
    curr.type === tks.LT_SIGN
    &amp;&amp; next.type === tks.IDENTIFIER
    &amp;&amp; !node._waitingForEndQuote
  ) {
    // Markup within expression
    valueNode = this.openNode(new MarkupNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  var pnw = this.previousNonWhitespace;

  if (
    curr.type === tks.FORWARD_SLASH
    &amp;&amp; !node._waitingForEndQuote
    &amp;&amp; pnw
    &amp;&amp; pnw.type !== tks.IDENTIFIER
    &amp;&amp; pnw.type !== tks.NUMERAL
    &amp;&amp; pnw.type !== tks.PAREN_CLOSE
  ) {
    valueNode = this.openNode(new RegexNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  // Default
  valueNode = ensureTextNode(node.values);

  if (
    !node._waitingForEndQuote
    &amp;&amp; (curr.type === tks.SINGLE_QUOTE || curr.type === tks.DOUBLE_QUOTE)
  ) {
    this.flag(node, '_waitingForEndQuote', curr.val);
    appendTextValue(valueNode, curr);
    return true;
  }

  if (
    curr.val === node._waitingForEndQuote
    &amp;&amp; !curr._considerEscaped
  ) {
    this.flag(node, '_waitingForEndQuote', null);
    appendTextValue(valueNode, curr);
    return true;
  }

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueExpressionNode" id="apidoc.element.vash.parser.prototype.continueExpressionNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueExpressionNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueExpressionNode = function (node, curr, next) {
  var valueNode = node.values[node.values.length-1];
  var pnw = this.previousNonWhitespace;

  if (
    curr.type === tks.AT
    &amp;&amp; next.type === tks.HARD_PAREN_OPEN
  ) {
    // LEGACY: @[], which means a legacy escape to content.
    updateLoc(node, curr);
    this.closeNode(node);
    return true;
  }

  if (curr.type === tks.PAREN_OPEN) {
    this.openNode(new ExplicitExpressionNode(), node.values);
    return false;
  }

  if (
    curr.type === tks.HARD_PAREN_OPEN
    &amp;&amp; node.values[0]
    &amp;&amp; node.values[0].type === 'VashExplicitExpression'
  ) {
    // @()[0], hard parens should be content
    updateLoc(node, curr);
    this.closeNode(node);
    return false;
  }

  if (
    curr.type === tks.HARD_PAREN_OPEN
    &amp;&amp; next.type === tks.HARD_PAREN_CLOSE
  ) {
    // [], empty index should be content (php forms...)
    updateLoc(node, curr);
    this.closeNode(node);
    return false;
  }

  if (curr.type === tks.HARD_PAREN_OPEN) {
    this.openNode(new IndexExpressionNode(), node.values);
    return false;
  }

  if (
    curr.type === tks.FORWARD_SLASH
    &amp;&amp; pnw
    &amp;&amp; pnw.type === tks.AT
  ) {
    this.openNode(new RegexNode(), node.values)
    return false;
  }

  // Default
  // Consume only specific cases, otherwise close.

  if (curr.type === tks.PERIOD &amp;&amp; next &amp;&amp; next.type === tks.IDENTIFIER) {
    valueNode = ensureTextNode(node.values);
    appendTextValue(valueNode, curr);
    return true;
  }

  if (curr.type === tks.IDENTIFIER) {

    if (node.values.length &gt; 0 &amp;&amp; valueNode &amp;&amp; valueNode.type !== 'VashText') {
      // Assume we just ended an explicit expression.
      this.closeNode(node);
      return false;
    }

    valueNode = ensureTextNode(node.values);
    appendTextValue(valueNode, curr);
    return true;
  } else {
    this.closeNode(node);
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueIndexExpressionNode" id="apidoc.element.vash.parser.prototype.continueIndexExpressionNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueIndexExpressionNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueIndexExpressionNode = function (node, curr, next) {
  var valueNode = node.values[node.values.length-1];

  if (node._waitingForEndQuote) {
    if (curr.val === node._waitingForEndQuote) {
      this.flag(node, '_waitingForEndQuote', null);
    }

    appendTextValue(valueNode, curr);
    return true;
  }

  if (
    curr.type === tks.HARD_PAREN_OPEN
    &amp;&amp; !valueNode
  ) {
    this.flag(node, '_waitingForHardParenClose', true);
    updateLoc(node, curr);
    return true;
  }

  if (curr.type === tks.HARD_PAREN_CLOSE) {
    this.flag(node, '_waitingForHardParenClose', false);
    this.closeNode(node);
    updateLoc(node, curr);
    return true;
  }

  if (curr.type === tks.PAREN_OPEN) {
    valueNode = this.openNode(new ExplicitExpressionNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  valueNode = ensureTextNode(node.values);

  if (!node._waitingForEndQuote
    &amp;&amp; (curr.type === tks.DOUBLE_QUOTE
    || curr.type === tks.SINGLE_QUOTE)
  ) {
    this.flag(node, '_waitingForEndQuote', curr.val);
    appendTextValue(valueNode, curr);
    return true;
  }

  // Default.

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueMarkupAttributeNode" id="apidoc.element.vash.parser.prototype.continueMarkupAttributeNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupAttributeNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueMarkupAttributeNode = function (node, curr, next) {

  var valueNode;

  if (
    curr.type === tks.AT
    &amp;&amp; !curr._considerEscaped
    &amp;&amp; next
    &amp;&amp; next.type === tks.AT
  ) {
    next._considerEscaped = true;
    return true;
  }

  if (curr.type === tks.AT &amp;&amp; !curr._considerEscaped) {
    // To expression

    valueNode = this.openNode(new ExpressionNode(), !node._finishedLeft
      ? node.left
      : node.right);

    updateLoc(valueNode, curr);
    return true;
  }

  // End of left, value only
  if (
    !node._expectRight
    &amp;&amp; (curr.type === tks.WHITESPACE
      || curr.type === tks.GT_SIGN
      || curr.type === tks.HTML_TAG_VOID_CLOSE)
  ) {
    this.flag(node, '_finishedLeft', true);
    updateLoc(node, curr);
    this.closeNode(node);
    return false; // defer
  }

  // End of left.
  if (curr.type === tks.EQUAL_SIGN &amp;&amp; !node._finishedLeft) {
    this.flag(node, '_finishedLeft', true);
    this.flag(node, '_expectRight', true);
    return true;
  }

  // Beginning of quoted value.
  if (
    node._expectRight
    &amp;&amp; !node.rightIsQuoted
    &amp;&amp; (curr.type === tks.DOUBLE_QUOTE
    || curr.type === tks.SINGLE_QUOTE)
  ) {
    this.flag(node, 'rightIsQuoted', curr.val);
    return true;
  }

  // End of quoted value.
  if (node.rightIsQuoted === curr.val) {
    updateLoc(node, curr);
    this.closeNode(node);
    return true;
  }

  // Default

  if (!node._finishedLeft) {
    valueNode = ensureTextNode(node.left);
  } else {
    valueNode = ensureTextNode(node.right);
  }

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueMarkupCommentNode" id="apidoc.element.vash.parser.prototype.continueMarkupCommentNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupCommentNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueMarkupCommentNode = function (node, curr, next) {
  var valueNode = node.values[node.values.length-1];

  if (curr.type === tks.HTML_COMMENT_OPEN) {
    this.flag(node, '_finishedOpen', true);
    this.flag(node, '_waitingForClose', tks.HTML_COMMENT_CLOSE);
    updateLoc(node, curr);
    valueNode = this.openNode(new MarkupContentNode(), node.values);
    return true;
  }

  if (curr.type === tks.HTML_COMMENT_CLOSE &amp;&amp; node._finishedOpen) {
    this.flag(node, '_waitingForClose', null);
    updateLoc(node, curr);
    this.closeNode(node);
    return true;
  }

  valueNode = ensureTextNode(node.values);
  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueMarkupContentNode" id="apidoc.element.vash.parser.prototype.continueMarkupContentNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupContentNode
        <span class="apidocSignatureSpan">(node, curr, next, ahead)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueMarkupContentNode = function (node, curr, next, ahead) {
  var valueNode = ensureTextNode(node.values);

  if (curr.type === tks.HTML_COMMENT_OPEN) {
    valueNode = this.openNode(new MarkupCommentNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  if (curr.type === tks.HTML_COMMENT_CLOSE) {
    updateLoc(node, curr);
    this.closeNode(node);
    return false;
  }

  if (curr.type === tks.AT_COLON &amp;&amp; !curr._considerEscaped) {
    this.flag(node, '_waitingForNewline', true);
    updateLoc(valueNode, curr);
    return true;
  }

  if (curr.type === tks.NEWLINE &amp;&amp; node._waitingForNewline === true) {
    this.flag(node, '_waitingForNewline', false);
    appendTextValue(valueNode, curr);
    updateLoc(node, curr);
    this.closeNode(node);
    return true;
  }

  if (
    curr.type === tks.AT
    &amp;&amp; !curr._considerEscaped
    &amp;&amp; next.type === tks.BRACE_OPEN
  ) {
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return true;
  }

  if (
    curr.type === tks.AT
    &amp;&amp; !curr._considerEscaped
    &amp;&amp; (next.type === tks.BLOCK_KEYWORD
      || next.type === tks.FUNCTION)
  ) {
    valueNode = this.openNode(new BlockNode(), node.values);
    updateLoc(valueNode, curr);
    return true;
  }

  // Mark @@: or @@ as escaped.
  if (
    curr.type === tks.AT
    &amp;&amp; !curr._considerEscaped
    &amp;&amp; next
    &amp;&amp; (
      next.type === tks.AT_COLON
      || next.type === tks.AT
      || next.type === tks.AT_STAR_OPEN
    )
  ) {
    next._considerEscaped = true;
    return true;
  }

  // @something
  if (curr.type === tks.AT &amp;&amp; !curr._considerEscaped) {
    valueNode = this.openNode(new ExpressionNode(), node.values);
    updateLoc(valueNode, curr);
    return true;
  }

  if (curr.type === tks.AT_STAR_OPEN &amp;&amp; !curr._considerEscaped) {
    this.openNode(new CommentNode(), node.values);
    return false;
  }

  var parent = this.stack[this.stack.length-2];

  // If this MarkupContent is the direct child of a block, it has no way to
  // know when to close. So in this case it should assume a } means it's
  // done. Or if it finds a closing html tag, of course.
  if (
    curr.type === tks.HTML_TAG_CLOSE
    || (curr.type === tks.BRACE_CLOSE
      &amp;&amp; parent &amp;&amp; parent.type === 'VashBlock')
  ) {
    this.closeNode(node);
    updateLoc(node, curr);
    return false;
  }

  if (
    curr.type === tks.LT_SIGN
    &amp;&amp; next
    &amp;&amp; (
      // If next is an IDENTIFIER, then try to ensure that it's likely an HTML
      // tag, which really can only be something like:
      // &lt;identifier&gt;
      // &lt;identifer morestuff (whitespace)
      // &lt;identifier\n
      // &lt;identifier@
      // &lt;identifier-
      // &lt;identifier:identifier // XML namespaces etc etc
      (next.type === tks.IDENTIFIER
        &amp;&amp; ahead
        &amp;&amp; (
          ahead.type === tks.GT_SIGN
          || ahead.type === tks.WHITESPACE
          || ahead.type === tks.NEWLINE
          || ahead.type === tks.AT
          || ahead.type === tks.UNARY_OPERATOR
          || ahead.type === tks.COLON
        )
      )
      || next.type === tks.AT)
  ) {
    // TODO: possibly check for same tag name, and if HTML5 incompatible,
    // such as p within p, then close current.
    valueNode = this.openNode(new MarkupNode(), node.values);
    updateLoc(valueNode, curr);
    return false;
  }

  // Ignore whitespace if the direct parent is a block. This is for backwards
  // compatibility with { @what() }, where the ' ' between ) and } should not
  // be included as content. This rule should not be followed if the
  // whitespace is contained within an @: escape or within favorText mode.
  if (
    curr.type === tks.WHITESPACE
    &amp;&amp; !node._waitingForNewline
    &amp;&amp; !this.opts.favorText
    &amp;&amp; parent
    &amp;&amp; parent.type === 'VashBlock'
  ) {
    return true;
  }

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueMarkupNode" id="apidoc.element.vash.parser.prototype.continueMarkupNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueMarkupNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueMarkupNode = function (node, curr, next) {
  var valueNode = node.values[node.values.length-1];

  if (curr.type === tks.LT_SIGN &amp;&amp; !node._finishedOpen) {
    updateLoc(node, curr);
    return true;
  }

  if (
    !node._finishedOpen
    &amp;&amp; curr.type !== tks.GT_SIGN
    &amp;&amp; curr.type !== tks.LT_SIGN
    &amp;&amp; curr.type !== tks.WHITESPACE
    &amp;&amp; curr.type !== tks.NEWLINE
    &amp;&amp; curr.type !== tks.HTML_TAG_VOID_CLOSE
  ) {

    // Assume tag name

    if (
      curr.type === tks.AT
      &amp;&amp; !curr._considerEscaped
      &amp;&amp; next
      &amp;&amp; next.type === tks.AT
    ) {
      next._considerEscaped = true;
      return true;
    }

    if (curr.type === tks.AT &amp;&amp; !curr._considerEscaped) {
      this.flag(node, 'expression', this.openNode(new ExpressionNode()));
      updateLoc(node.expression, curr);
      return true;
    }

    node.name = node.name
      ? node.name + curr.val
      : curr.val;
    updateLoc(node, curr);
    return true;
  }

  if (curr.type === tks.GT_SIGN &amp;&amp; !node._waitingForFinishedClose) {
    this.flag(node, '_finishedOpen', true);

    if (MarkupNode.isVoid(node.name)) {
      this.flag(node, 'isVoid', true);
      this.closeNode(node);
      updateLoc(node, curr);
    } else {
      valueNode = this.openNode(new MarkupContentNode(), node.values);
      updateLoc(valueNode, curr);
    }

    return true;
  }

  if (curr.type === tks.GT_SIGN &amp;&amp; node._waitingForFinishedClose) {
    this.flag(node, '_waitingForFinishedClose', false);
    this.closeNode(node);
    updateLoc(node, curr);
    return true;
  }

  // &lt;/VOID
  if (
    curr.type === tks.HTML_TAG_CLOSE
    &amp;&amp; next
    &amp;&amp; next.type === tks.IDENTIFIER
    &amp;&amp; MarkupNode.isVoid(next.val)
  ) {
    throw newUnexpectedClosingTagError(this, curr, curr.val + next.val);
  }

  // &lt;/
  if (curr.type === tks.HTML_TAG_CLOSE) {
    this.flag(node, '_waitingForFinishedClose', true);
    this.flag(node, 'isClosed', true);
    return true;
  }

  // --&gt;
  if (curr.type === tks.HTML_COMMENT_CLOSE) {
    this.flag(node, '_waitingForFinishedClose', false);
    this.closeNode(node);
    return false;
  }

  if (curr.type === tks.HTML_TAG_VOID_CLOSE) {
    this.closeNode(node);
    this.flag(node, 'isVoid', true);
    this.flag(node, 'voidClosed', true);
    this.flag(node, 'isClosed', true);
    updateLoc(node, curr);
    return true;
  }

  if (node._waitingForFinishedClose) {
    this.lg('Ignoring %s while waiting for closing GT_SIGN',
      curr);
    return true;
  }

  if (
    (curr.type === tks.WHITESPACE || curr.type === tks.NEWLINE)
    &amp;&amp; !node._finishedOpen
    &amp;&amp; next.type !== tks.HTML_TAG_VOID_CLOSE
    &amp;&amp; next.type !== tks.GT_SIGN
    &amp;&amp; next.type !== tks.NEWLINE
    &amp;&amp; next.type !== tks.WHITESPACE
  ) {
    // enter attribute
    valueNode = this.openNode(new MarkupAttributeNode(), node.attributes);
    updateLoc(valueNode, curr);
    return true;
  }

  // Whitespace between attributes should be ignored.
  if (
    (curr.type === tks.WHITESPACE || curr.type === tks.NEWLINE)
    &amp;&amp; !node._finishedOpen
  ) {
    updateLoc(node, curr);
    return true;
  }

  // Can't really have non-markupcontent within markup, so implicitly open
  // a node. #68.
  if (node._finishedOpen) {
    valueNode = this.openNode(new MarkupContentNode(), this.node.values);
    updateLoc(valueNode, curr);
    return false; // defer
  }

  // Default

  //valueNode = ensureTextNode(node.values);
  //appendTextValue(valueNode, curr);
  //return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.continueRegexNode" id="apidoc.element.vash.parser.prototype.continueRegexNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>continueRegexNode
        <span class="apidocSignatureSpan">(node, curr, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueRegexNode = function (node, curr, next) {
  var valueNode = ensureTextNode(node.values);

  if (
    curr.type === tks.FORWARD_SLASH
    &amp;&amp; !node._waitingForForwardSlash
    &amp;&amp; !curr._considerEscaped
  ) {
    // Start of regex.
    this.flag(node, '_waitingForForwardSlash', true);
    appendTextValue(valueNode, curr);
    return true;
  }

  if (
    curr.type === tks.FORWARD_SLASH
    &amp;&amp; node._waitingForForwardSlash
    &amp;&amp; !curr._considerEscaped
  ) {
    // "End" of regex.
    this.flag(node, '_waitingForForwardSlash', null);
    this.flag(node, '_waitingForFlags', true);
    appendTextValue(valueNode, curr);
    return true;
  }

  if (node._waitingForFlags) {
    this.flag(node, '_waitingForFlags', null);
    this.closeNode(node);

    if (curr.type === tks.IDENTIFIER) {
      appendTextValue(valueNode, curr);
      return true;
    } else {
      return false;
    }
  }

  if (
    curr.type === tks.BACKSLASH
    &amp;&amp; !curr._considerEscaped
  ) {
    next._considerEscaped = true;
  }

  appendTextValue(valueNode, curr);
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.decorateError" id="apidoc.element.vash.parser.prototype.decorateError">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>decorateError
        <span class="apidocSignatureSpan">(err, line, column)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorateError = function (err, line, column) {
  err.message = ''
    + err.message
    + ' at template line ' + line
    + ', column ' + column + '\n\n'
    + 'Context: \n'
    + error.context(this.inputText, line, column, '\n')
    + '\n';

  return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    node = this.stack[i];
    if (node.endOk &amp;&amp; !node.endOk()) {
      // Attempt to make the error readable
      delete node.values;
      msg = 'Found unclosed ' + node.type;
      var err = new Error(msg);
      err.name = 'UnclosedNodeError';
      throw this.<span class="apidocCodeKeywordSpan">decorateError</span>(
        err,
        node.startloc.line,
        node.startloc.column);
    }
    i--;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.dumpAST" id="apidoc.element.vash.parser.prototype.dumpAST">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>dumpAST
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dumpAST = function () {
  if (!this.stack.length) {
    var msg = 'No AST to dump.';
    throw new Error(msg);
  }

  return JSON.stringify(this.stack[0], null, '  ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  while(more !== null) more = p.read();

  p.checkStack();

  // Stash the original input (new lines normalized by the lexer).
  opts.source = l.originalInput;

  p.lg(p.<span class="apidocCodeKeywordSpan">dumpAST</span>());

  var compiled = codegen(p.stack[0], opts);
  lg(compiled);
  var tpl = runtime.link(compiled, opts);

  return tpl;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.flag" id="apidoc.element.vash.parser.prototype.flag">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>flag
        <span class="apidocSignatureSpan">(node, name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flag = function (node, name, value) {
  var printVal = (value &amp;&amp; typeof value === 'object')
    ? value.type
    : value;
  this.lg('Flag %s on node %s was %s now %s',
    name, node.type, node[name], printVal);
  node[name] = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.node = last;
}

Parser.prototype.continueCommentNode = function(node, curr, next) {
var valueNode = ensureTextNode(node.values);

if (curr.type === tks.AT_STAR_OPEN &amp;&amp; !node._waitingForClose) {
  this.<span class="apidocCodeKeywordSpan">flag</span>(node, '_waitingForClose', tks.AT_STAR_CLOSE)
  updateLoc(node, curr);
  return true;
}

if (curr.type === node._waitingForClose) {
  this.flag(node, '_waitingForClose', null)
  updateLoc(node, curr);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.openNode" id="apidoc.element.vash.parser.prototype.openNode">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>openNode
        <span class="apidocSignatureSpan">(node, opt_insertArr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openNode = function (node, opt_insertArr) {
  this.stack.push(node);
  this.lg('Opened node %s from %s',
    node.type, (this.node ? this.node.type : null));
  this.node = node;

  if (opt_insertArr) {
    opt_insertArr.push(node);
  }

  return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.tokens.unshift.apply(this.tokens, tokens.reverse());
}

Parser.prototype.read = function() {
if (!this.tokens.length &amp;&amp; !this.deferredTokens.length) return null;

if (!this.node) {
  this.<span class="apidocCodeKeywordSpan">openNode</span>(new ProgramNode());
  this.openNode(new MarkupNode(), this.node.body);
  this.node._finishedOpen = true;
  this.node.name = 'text';
  updateLoc(this.node, { line: 0, chr: 0 })
  this.openNode(new MarkupContentNode(), this.node.values);
  updateLoc(this.node, { line: 0, chr: 0 })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.read" id="apidoc.element.vash.parser.prototype.read">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {
  if (!this.tokens.length &amp;&amp; !this.deferredTokens.length) return null;

  if (!this.node) {
    this.openNode(new ProgramNode());
    this.openNode(new MarkupNode(), this.node.body);
    this.node._finishedOpen = true;
    this.node.name = 'text';
    updateLoc(this.node, { line: 0, chr: 0 })
    this.openNode(new MarkupContentNode(), this.node.values);
    updateLoc(this.node, { line: 0, chr: 0 })
  }

  var curr = this.deferredTokens.pop() || this.tokens.pop();

  // To find this value we must search through both deferred and
  // non-deferred tokens, since there could be more than just 3
  // deferred tokens.
  // nextNonWhitespaceOrNewline
  var nnwon = null;

  for (var i = this.deferredTokens.length-1; i &gt;= 0; i--) {
    if (
      nnwon
      &amp;&amp; nnwon.type !== tks.WHITESPACE
      &amp;&amp; nnwon.type !== tks.NEWLINE
    ) break;
    nnwon = this.deferredTokens[i];
  }

  for (var i = this.tokens.length-1; i &gt;= 0; i--) {
    if (
      nnwon
      &amp;&amp; nnwon.type !== tks.WHITESPACE
      &amp;&amp; nnwon.type !== tks.NEWLINE
    ) break;
    nnwon = this.tokens[i];
  }

  var next = this.deferredTokens.pop() || this.tokens.pop();
  var ahead = this.deferredTokens.pop() || this.tokens.pop();

  var dispatch = 'continue' + this.node.constructor.name;

  this.lg('Read: %s', dispatch);
  this.lg('  curr %s', curr);
  this.lg('  next %s', next);
  this.lg('  ahead %s', ahead);
  this.lg('  nnwon %s', nnwon);

  if (curr._considerEscaped) {
    this.lg('  Previous token was marked as escaping');
  }

  var consumed = this[dispatch](this.node, curr, next, ahead, nnwon);

  if (ahead) {
    // ahead may be undefined when about to run out of tokens.
    this.deferredTokens.push(ahead);
  }

  if (next) {
    // Next may be undefined when about to run out of tokens.
    this.deferredTokens.push(next);
  }

  if (!consumed) {
    this.lg('Deferring curr %s', curr);
    this.deferredTokens.push(curr);
  } else {

    if (curr.type !== tks.WHITESPACE) {
      this.lg('set previousNonWhitespace %s', curr);
      this.previousNonWhitespace = curr;
    }

    // Poor man's ASI.
    if (curr.type === tks.NEWLINE) {
      this.lg('set previousNonWhitespace %s', null);
      this.previousNonWhitespace = null;
    }

    if (!curr._considerEscaped &amp;&amp; curr.type === tks.BACKSLASH) {
      next._considerEscaped = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var opts = copyrtl({}, exports.config, options || {});

var l = new Lexer();

l.write(markup);
var tokens = l.<span class="apidocCodeKeywordSpan">read</span>();

var p = new Parser(opts);
p.write(tokens);
var more = true;
while(more !== null) more = p.read();

p.checkStack();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.parser.prototype.write" id="apidoc.element.vash.parser.prototype.write">
        function <span class="apidocSignatureSpan">vash.parser.prototype.</span>write
        <span class="apidocSignatureSpan">(tokens)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (tokens) {
  if (!Array.isArray(tokens)) tokens = [tokens];
  this.inputText += tokens.map(function(tok) { return tok.val; }).join('');
  this.tokens.unshift.apply(this.tokens, tokens.reverse());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error('Empty or non-string cannot be compiled');
}

var opts = copyrtl({}, exports.config, options || {});

var l = new Lexer();

l.<span class="apidocCodeKeywordSpan">write</span>(markup);
var tokens = l.read();

var p = new Parser(opts);
p.write(tokens);
var more = true;
while(more !== null) more = p.read();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vash.runtime" id="apidoc.module.vash.runtime">module vash.runtime</a></h1>


    <h2>
        <a href="#apidoc.element.vash.runtime.Mark" id="apidoc.element.vash.runtime.Mark">
        function <span class="apidocSignatureSpan">vash.runtime.</span>Mark
        <span class="apidocSignatureSpan">( buffer, debugName )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Mark = function ( buffer, debugName ){
  this.uid = '[VASHMARK-'
    + ~~( Math.random() * 10000000 )
    + (debugName ? ':' + debugName : '')
    + ']';
  this.markedIndex = 0;
  this.buffer = buffer;
  this.destroyed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.runtime.install" id="apidoc.element.vash.runtime.install">
        function <span class="apidocSignatureSpan">vash.runtime.</span>install
        <span class="apidocSignatureSpan">( path, tpl )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">install = function ( path, tpl ){
  var cache = runtime.helpers.tplcache;
  if( typeof tpl === 'string' ){
    // Super hacky: if the calling context has a `compile` function,
    // then `this` is likely full vash. This is simply for backwards
    // compatibility.
    // TODO: @deprecate
    if ( typeof this.compile === 'function') {
      tpl = this.compile(tpl);
    } else {
      throw new Error('.install(path, [string]) is not available in the standalone runtime.');
    }
  } else if( typeof path === 'object' ){
    tpl = path;
    Object.keys(tpl).forEach(function(path){
      cache[path] = tpl[path];
    });
    return cache;
  }
  return cache[path] = tpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If `model` is passed and the template is found, the template is automatically executed and returned using `model` as the model.

&lt;a name="vash-install"&gt;&lt;/a&gt;vash.install
--------------------

`vash.install` accepts a few signatures:

	vash.<span class="apidocCodeKeywordSpan">install</span>(str_path, func_tpl) -&gt; func_tpl

"Saves" the template at `vash.helpers.tplcache[str_path]`.

	vash.install(str_path, str_tpl) -&gt; func_tpl

If `vash.compile` is available (meaning the entire compiler is available, not just the runtime), then the string is automatically
 compiled. and saved at `vash.helpers.tplcache[str_path]`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.runtime.link" id="apidoc.element.vash.runtime.link">
        function <span class="apidocSignatureSpan">vash.runtime.</span>link
        <span class="apidocSignatureSpan">( cmpFunc, options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function ( cmpFunc, options ){

  // TODO: allow options.filename to be used as sourceUrl?

  var  originalFunc
    ,cmpOpts;

  if( !options.args ){
    // every template has these arguments
    options.args = [options.modelName, options.helpersName, '__vopts', 'runtime'];
  }

  if( typeof cmpFunc === 'string' ){
    originalFunc = cmpFunc;

    try {
      // do not pollute the args array for later attachment to the compiled
      // function for later decompilation/linking
      cmpOpts = options.args.slice();
      cmpOpts.push(cmpFunc);
      cmpFunc = Function.apply(null, cmpOpts);
    } catch(e) {
      // TODO: add flag to reportError to know if it's at compile time or runtime
      helpers.reportError(e, 0, 0, originalFunc, /\n/, false);
    }
  }

  // need this to enable decompilation / relinking
  cmpFunc.options = {
     simple: options.simple
    ,modelName: options.modelName
    ,helpersName: options.helpersName
  }

  var linked;

  if( options.asHelper ){

    cmpFunc.options.args = options.args;
    cmpFunc.options.asHelper = options.asHelper;

    linked = function(){
      return cmpFunc.apply(this, slice.call(arguments));
    }

    helpers[options.asHelper] = linked;

  } else {

    linked = function( model, opts ){
      if( options.simple ){
        var ctx = {
           buffer: []
          ,escape: Helpers.prototype.escape
          ,raw: Helpers.prototype.raw
        }
        return cmpFunc( model, ctx, opts, runtime );
      }

      opts = divineRuntimeTplOptions( model, opts );
      return cmpFunc( model, (opts &amp;&amp; opts.context) || new Helpers( model ), opts, runtime );
    }
  }

  // show the template-specific code, instead of the generic linked function
  linked['toString'] = function(){ return cmpFunc.toString(); }

  // shortcut to show the actual linked function
  linked['_toString'] = function(){ return Function.prototype.toString.call(linked) }

  // This assumes a vash global, and should be deprecated.
  // TODO: @deprecate
  linked['toClientString'] = function(){
    return 'vash.link( '
      + cmpFunc.toString() + ', '
      + JSON.stringify( cmpFunc.options ) + ' )';
  }

  return linked;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		return (__vopts &amp;&amp; __vopts.asContext)
			? html
			: html.toString();
	}

If `toClientString` is called on that function, the following is returned:

	vash.<span class="apidocCodeKeywordSpan">link</span>( function anonymous(model,html,__vopts,vash) {
		var __vbuffer = html.buffer;
		html.options = __vopts;
		model = model || {};
		__vbuffer.push('&lt;p&gt;&lt;/p&gt;\n');
		(__vopts &amp;&amp; __vopts.onRenderEnd &amp;&amp; __vopts.onRenderEnd(null, html));
		return (__vopts &amp;&amp; __vopts.asContext)
			? html
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.runtime.lookup" id="apidoc.element.vash.runtime.lookup">
        function <span class="apidocSignatureSpan">vash.runtime.</span>lookup
        <span class="apidocSignatureSpan">( path, model )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function ( path, model ){
  var tpl = runtime.helpers.tplcache[path];
  if( !tpl ){ throw new Error('Could not find template: ' + path); }
  if( model ){ return tpl(model); }
  else return tpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This is primarily an internal function, and has relatively complex behavioral differences depending on what options are passed in
. It takes either a decompiled string function or function instance and "links" it by wrapping it in a closure that provides
 access to Vash's runtime functions. It also sets up things like `toClientString` and `toString`. It makes precompiled functions
 possible. As a developer working on Vash, it's best to take a look at the [source itself][].

[source itself]: https://github.com/kirbysayshi/vash/blob/master/src/vruntime.js

&lt;a name="vash-lookup"&gt;&lt;/a&gt;vash.lookup
-------------------

	vash.<span class="apidocCodeKeywordSpan">lookup</span>(str_path) -&gt; Function

Attempts to grab a template from `vash.helpers.tplcache[str_path]`, and throws an exception if it is not found.

	vash.lookup(str_path, model) -&gt; Function

If `model` is passed and the template is found, the template is automatically executed and returned using `model` as the model.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vash.runtime.uninstall" id="apidoc.element.vash.runtime.uninstall">
        function <span class="apidocSignatureSpan">vash.runtime.</span>uninstall
        <span class="apidocSignatureSpan">( path )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uninstall = function ( path ){
  var  cache = runtime.helpers.tplcache
    ,deleted = false;

  if( typeof path === 'string' ){
    return delete cache[path];
  } else {
    Object.keys(cache).forEach(function(key){
      if( cache[key] === path ){ deleted = delete cache[key]; }
    })
    return deleted;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	vash.install(obj) -&gt; obj

If an object containing string keys pointing at template functions is passed, then the object's keys are used as the keys for
 `vash.helpers.tplcache`. This is especially useful when using [vash.compileBatch][], as the result can be directly passed.

&lt;a name="vash-uninstall"&gt;&lt;/a&gt;vash.uninstall
----------------------

	vash.<span class="apidocCodeKeywordSpan">uninstall</span>(str_path) -&gt; bool

Deletes the key named `str_path` from `vash.helpers.tplcache`.

	vash.uninstall(func_tpl) -&gt; bool

Loops through all templates in `vash.helpers.tplcache`, and if a strict equality is successful, deletes that reference.
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>